--- PAOFLOW/examples/check_test.py	(original)
+++ PAOFLOW/examples/check_test.py	(refactored)
@@ -32,7 +32,7 @@
     tolerance = 0.005  # Percentage that error can deviate from average to pass tests
     ######### End User Defined Variables ########
 
-    print('Verifying .dat files for %s' % subdir)
+    print(('Verifying .dat files for %s' % subdir))
 
     # Get new data files and existing reference data files
     datFiles = glob.glob('*.dat')
@@ -78,7 +78,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -107,15 +107,15 @@
             allDataResult = result = 'FAIL'
 
         if showErrors:
-            print('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError))
+            print(('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError)))
         if showFileResult:
-            print('\t%s ---------- [%s]\n' % (datFiles[i], result))
+            print(('\t%s ---------- [%s]\n' % (datFiles[i], result)))
 
     if showErrors:
-        print('The maximum absolute error in %s was %E in %s' % (subdir, maxError, datFiles[maxErrorIndex]))
-        print('The maximum relative error in %s was %E in %s' % (subdir, maxRelError, datFiles[maxRelErrorIndex]))
+        print(('The maximum absolute error in %s was %E in %s' % (subdir, maxError, datFiles[maxErrorIndex])))
+        print(('The maximum relative error in %s was %E in %s' % (subdir, maxRelError, datFiles[maxRelErrorIndex])))
 
-    print('%s ---------- [%s]\n' % (subdir, allDataResult))
+    print(('%s ---------- [%s]\n' % (subdir, allDataResult)))
 
 
 def main():
@@ -136,7 +136,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/examples/run_examples.py	(original)
+++ PAOFLOW/examples/run_examples.py	(refactored)
@@ -67,10 +67,10 @@
         command = get_exeCmd(engine[calc.split("_")[0]],calc.split("_")[0],fileList[n])
         n += 1
         try:
-            print "%s in %s"%(command, subdir)
+            print("%s in %s"%(command, subdir))
             subprocess.check_output([command],shell=True)
         except subprocess.CalledProcessError as e:
-            print "######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+            print("######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
             raise SystemExit
     return
 
@@ -90,20 +90,20 @@
         if refPattern[len(refPattern)-1] != '/':
             refPattern += '/'
 
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         try:
             oneRun(subdir)
         except:
-            print('Exception in %s'%subdir)
+            print(('Exception in %s'%subdir))
             quit()
         verifyData(subdir, refPattern)
         os.chdir('../')
-        print('test run in %5s sec ' %str('%.3f' %(time.time()-reset)).rjust(10))
+        print(('test run in %5s sec ' %str('%.3f' %(time.time()-reset)).rjust(10)))
         reset=time.time()
 
-    print('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10))
+    print(('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10)))
 
 if __name__ == "__main__":
     main()
--- PAOFLOW/src/PAOFLOW.py	(original)
+++ PAOFLOW/src/PAOFLOW.py	(refactored)
@@ -24,7 +24,7 @@
 # *************************************************************************************
 
 # future imports
-from __future__ import absolute_import, print_function
+
 
 # import general modules
 import os, sys, traceback, psutil, time
@@ -288,7 +288,7 @@
             # Check projectability and decide bnd
     
             bnd = 0
-            for n in xrange(nbnds):
+            for n in range(nbnds):
                 if Pn[n] > pthr:
                     bnd += 1
             Pn = None
@@ -371,37 +371,37 @@
             else:
                 if nspin == 1:
                     f=open(os.path.join(inputpath,'kham.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,0]),np.imag(Hks[i,j,ik,0])))
                     f.close()
                 elif nspin == 2:
                     f=open(os.path.join(inputpath,'kham_up.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,0]),np.imag(Hks[i,j,ik,0])))
                     f.close()
                     f=open(os.path.join(inputpath,'kham_down.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,1]),np.imag(Hks[i,j,ik,1])))
                     f.close()
                 if non_ortho:
                     f=open(os.path.join(inputpath,'kovp.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Sks[i,j,ik]),np.imag(Sks[i,j,ik])))
                     f.close()
             f=open(os.path.join(inputpath,'k.txt'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 f.write('%20.13f %20.13f %20.13f \n' %(kpnts[ik,0],kpnts[ik,1],kpnts[ik,2]))
             f.close()
             f=open(os.path.join(inputpath,'wk.txt'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 f.write('%20.13f \n' %(kpnts_wght[ik]))
             f.close()
     
@@ -489,8 +489,8 @@
             # Add external fields or non scf ACBN0 correction
             tau_wf = np.zeros((nawf,3),dtype=float)
             l=0
-            for n in xrange(natoms):
-                for i in xrange(naw[n]):
+            for n in range(natoms):
+                for i in range(naw[n]):
                     tau_wf[l,:] = tau[n,:]
                     l += 1
     
@@ -586,7 +586,7 @@
             # Define k-point mesh for bands interpolation
             kq = kpnts_interpolation_mesh(ibrav,alat,a_vectors,b_vectors,nk,inputpath)
             nkpi=kq.shape[1]
-            for n in xrange(nkpi):
+            for n in range(nkpi):
                 kq[:,n]=np.dot(kq[:,n],b_vectors)
     
             # Compute the bands along the path in the IBZ
@@ -1093,7 +1093,7 @@
             # Compute velocities for Boltzmann transport
             #----------------------
             velkp = np.zeros((pksp.shape[0],3,bnd,nspin),dtype=float)
-            for n in xrange(bnd):
+            for n in range(bnd):
                 velkp[:,:,n,:] = np.real(pksp[:,:,n,n,:])
 
 
@@ -1106,9 +1106,9 @@
                     # Find critical points (grad(E_kn)=0)
                     #----------------------
                     f=open(os.path.join(inputpath,'critical_points.dat'),'w')
-                    for ik in xrange(nk1*nk2*nk3):
-                        for n in xrange(bnd):
-                            for ipin in xrange(nspin):
+                    for ik in range(nk1*nk2*nk3):
+                        for n in range(bnd):
+                            for ipin in range(nspin):
                                 if  np.abs(velkp_full[ik,0,n,ispin]) < 1.e-2 and \
                                     np.abs(velkp_full[ik,1,n,ispin]) < 1.e-2 and \
                                     np.abs(velkp_full[ik,2,n,ispin]) < 1.e-2:
@@ -1161,7 +1161,7 @@
                 #----------------------
                 # PDOS calculation
                 #----------------------    
-                for ispin in xrange(nspin):
+                for ispin in range(nspin):
                     do_pdos_calc_adaptive(E_k[:,:,ispin],emin,emax,deltakp[:,:,ispin],v_k[:,:,:,ispin],
                                           nk1,nk2,nk3,nawf,ispin,smearing,inputpath)
 
@@ -1229,7 +1229,7 @@
         #----------------------
         if spin_Hall:
             if dftSO == False: sys.exit('full relativistic calculation with SO needed')
-            for n in xrange(s_tensor.shape[0]):
+            for n in range(s_tensor.shape[0]):
                 ipol = s_tensor[n][0]
                 jpol = s_tensor[n][1]
                 spol = s_tensor[n][2]
@@ -1285,18 +1285,18 @@
                 if rank == 0:
                     shc *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                     f=open(os.path.join(inputpath,'shcEf_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e \n' %(ene[n],shc[n]))
                     f.close()
     
                     if  ac_cond_spin:
                         sigxy *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                         f=open(os.path.join(inputpath,'SCDi_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.imag(ene_ac[n]*sigxy[n]/105.4571)))  #convert energy in freq (1/hbar in cgs units)
                         f.close()
                         f=open(os.path.join(inputpath,'SCDr_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.real(sigxy[n])))
                         f.close()
 
@@ -1321,7 +1321,7 @@
         if Berry:
             if dftSO == False: sys.exit('full relativistic calculation with SO needed')
  
-            for n in xrange(a_tensor.shape[0]):
+            for n in range(a_tensor.shape[0]):
                 ipol = a_tensor[n][0]
                 jpol = a_tensor[n][1]
                 ene,ahc,Om_k = do_Berry_curvature(E_k,pksp,nk1,nk2,nk3,npool,ipol,jpol,
@@ -1350,18 +1350,18 @@
                 if rank == 0:
                     ahc *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                     f=open(os.path.join(inputpath,'ahcEf_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e \n' %(ene[n],ahc[n]))
                     f.close()
     
                     if ac_cond_Berry:
                         sigxy *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                         f=open(os.path.join(inputpath,'MCDi_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.imag(ene_ac[n]*sigxy[n]/105.4571)))  #convert energy in freq (1/hbar in cgs units)
                         f.close()
                         f=open(os.path.join(inputpath,'MCDr_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.real(sigxy[n])))
                         f.close()
     
@@ -1380,7 +1380,7 @@
         # Compute transport quantities (conductivity, Seebeck and thermal electrical conductivity)
         #----------------------
         if Boltzmann:
-            for ispin in xrange(nspin):
+            for ispin in range(nspin):
     
                 if smearing == None:
                     ene,L0,L1,L2 = do_Boltz_tensors(E_k,velkp,kq_wght,temp,ispin,deltakp,smearing,t_tensor)
@@ -1395,7 +1395,7 @@
                       (ELECTRONVOLT_SI/(H_OVER_TPI**2*BOHR_RADIUS_SI))*1.0e-21
                 if rank == 0:
                     f=open(os.path.join(inputpath,'sigma_'+str(ispin)+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                             %(ene[n],L0[0,0,n],L0[1,1,n],L0[2,2,n],L0[0,1,n],L0[0,2,n],L0[1,2,n]))
                     f.close()
@@ -1411,7 +1411,7 @@
                     L1 *= (ELECTRONVOLT_SI**2/(4.0*np.pi**3))*(ELECTRONVOLT_SI**2/(H_OVER_TPI**2*BOHR_RADIUS_SI))
     
                     if rank == 0:
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             try:
                                 S[:,:,n] = LAN.inv(L0[:,:,n])*L1[:,:,n]*(-K_BOLTZMAN_SI/(temp*ELECTRONVOLT_SI**2))*1.e4
                             except:
@@ -1419,7 +1419,7 @@
                                 raise ValueError
     
                         f=open(os.path.join(inputpath,'Seebeck_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                                     %(ene[n],S[0,0,n],S[1,1,n],S[2,2,n],S[0,1,n],S[0,2,n],S[1,2,n]))
                         f.close()
@@ -1433,11 +1433,11 @@
                     L2 *= (ELECTRONVOLT_SI**2/(4.0*np.pi**3))*(ELECTRONVOLT_SI**3/(H_OVER_TPI**2*BOHR_RADIUS_SI))
     
                     if rank == 0:
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             kappa[:,:,n] = (L2[:,:,n] - L1[:,:,n]*LAN.inv(L0[:,:,n])*L1[:,:,n])*(K_BOLTZMAN_SI/(temp*ELECTRONVOLT_SI**3))*1.e-15
     
                         f=open(os.path.join(inputpath,'kappa_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                                     %(ene[n],kappa[0,0,n],kappa[1,1,n],kappa[2,2,n],kappa[0,1,n],kappa[0,2,n],kappa[1,2,n]))
                         f.close()
@@ -1471,25 +1471,25 @@
     
             omega = alat**3 * np.dot(a_vectors[0,:],np.cross(a_vectors[1,:],a_vectors[2,:]))
     
-            for n in xrange(d_tensor.shape[0]):
+            for n in range(d_tensor.shape[0]):
                 ipol = d_tensor[n][0]
                 jpol = d_tensor[n][1]
-                for ispin in xrange(nspin):
+                for ispin in range(nspin):
                     ene, epsi, epsr, jdos = do_epsilon(E_k,pksp,kq_wght,omega,shift,delta,temp,ipol,jpol,ispin,metal,ne,epsmin,epsmax,deltakp,deltakp2,smearing,kramerskronig)
     
                     if rank == 0:
                         f=open(os.path.join(inputpath,'epsi_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],epsi[ipol,jpol,n]))
                         f.close()
                         f=open(os.path.join(inputpath,'epsr_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],epsr[ipol,jpol,n]))
                         f.close()
                         f=open(os.path.join(inputpath,'jdos_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],jdos[n]))
                         f.close()
--- PAOFLOW/src/main.py	(original)
+++ PAOFLOW/src/main.py	(refactored)
@@ -24,7 +24,7 @@
 # *************************************************************************************
 
 # future imports
-from __future__ import print_function
+
 
 import sys
 import numpy as np
@@ -50,7 +50,7 @@
     # Check for output dictionary and print the keys.
     if outDict is not None:
         print('\noutDict keys:')
-        for k in outDict.keys():
+        for k in list(outDict.keys()):
             print('\''+k+'\'')
 
 if __name__== "__main__":
--- PAOFLOW/src/defs/add_ext_field.py	(original)
+++ PAOFLOW/src/defs/add_ext_field.py	(refactored)
@@ -29,7 +29,7 @@
 
     if Efield.any() != 0.0:
         # Electric field
-        for n in xrange(nawf):
+        for n in range(nawf):
             HRs[n,n,0,:] -= Efield.dot(tau_wf[n,:])
 
     if Bfield.any() != 0.0:
@@ -43,7 +43,7 @@
     #            HRs[n,m,i,:] *= np.exp(-np.pi*arg*1.j)
 
     if HubbardU.any() != 0:
-        for n in xrange(nawf):
+        for n in range(nawf):
             HRs[n,n,0,:] -= HubbardU[n]/2.0
 
     HRs = np.reshape(HRs,(nawf,nawf,nk1,nk2,nk3,nspin),order='C')
--- PAOFLOW/src/defs/build_Hks.py	(original)
+++ PAOFLOW/src/defs/build_Hks.py	(refactored)
@@ -22,8 +22,8 @@
         Hks = np.zeros((bnd,bnd,nkpnts,nspin),dtype=complex)
     else:
         Hks = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ik in xrange(nkpnts):
-        for ispin in xrange(nspin):
+    for ik in range(nkpnts):
+        for ispin in range(nspin):
             my_eigs=my_eigsmat[:,ik,ispin]
             #Building the Hamiltonian matrix
             E = np.diag(my_eigs)
@@ -32,7 +32,7 @@
             UU[:,:nawf] = UU[:,:nawf]*norms[:nawf]
             # Choose only the eigenvalues that are below the energy shift
             bnd_ik=0
-            for n in xrange(bnd):
+            for n in range(bnd):
                 if my_eigs[n] <= eta:
                     bnd_ik += 1
             if bnd_ik == 0: sys.exit('no eigenvalues in selected energy range')
--- PAOFLOW/src/defs/build_Pn.py	(original)
+++ PAOFLOW/src/defs/build_Pn.py	(refactored)
@@ -13,8 +13,8 @@
 
 def build_Pn(nawf,nbnds,nkpnts,nspin,U):
     Pn = 0.0
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             UU = np.transpose(U[:,:,ik,ispin]) #transpose of U. Now the columns of UU are the eigenvector of length nawf
             Pn += np.real(np.sum(np.conj(UU)*UU,axis=0))/nkpnts/nspin
     return Pn
--- PAOFLOW/src/defs/calc_PAO_eigs_vecs.py	(original)
+++ PAOFLOW/src/defs/calc_PAO_eigs_vecs.py	(refactored)
@@ -40,7 +40,7 @@
 
 
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         E_kaux[:,:,ispin], v_kaux[:,:,:,ispin] = diago(aux.shape[0],aux[:,:,:,ispin])
 
     aux = None
@@ -52,7 +52,7 @@
     ekp = np.zeros((nsize,nawf),dtype=float)
     ekv = np.zeros((nsize,nawf,nawf),dtype=complex)
 
-    for n in xrange(nsize):
+    for n in range(nsize):
         eigval,eigvec = LAN.eigh(aux[n,:,:],UPLO='U')
         ekp[n,:] = np.real(eigval)
         ekv[n,:,:] = eigvec
--- PAOFLOW/src/defs/clebsch_gordan.py	(original)
+++ PAOFLOW/src/defs/clebsch_gordan.py	(refactored)
@@ -62,7 +62,7 @@
         Ul1[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul1[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul1[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -80,7 +80,7 @@
         Ul2[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul2[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul2[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -98,7 +98,7 @@
         Ul3[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul3[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul3[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -118,14 +118,14 @@
     nl = np.asarray(nl)
 
     ntot = 0
-    for n in xrange(len(sh)):
+    for n in range(len(sh)):
         ntot += nl[n]*occ[sh[n]]
     if ntot != nawf: sys.exit('wrong number of shells in reading')
     Tn = np.zeros((ntot,ntot),dtype=float)
 
     n = 0
-    for l in xrange(len(sh)):
-        for i in xrange(nl[l]):
+    for l in range(len(sh)):
+        for i in range(nl[l]):
             Tn[n:n+occ[sh[l]],n:n+occ[sh[l]]] = Ul[sh[l]]
             n += occ[sh[l]]
 
@@ -134,7 +134,7 @@
 
     # Spin operator matrix  in the basis of |l,m,s,s_z>
     Sl = np.zeros((nawf,nawf),dtype=complex)
-    for i in xrange(0,nawf,2):
+    for i in range(0,nawf,2):
         Sl[i,i] = sP[spol][0,0]
         Sl[i,i+1] = sP[spol][0,1]
         Sl[i+1,i] = sP[spol][1,0]
--- PAOFLOW/src/defs/communication.py	(original)
+++ PAOFLOW/src/defs/communication.py	(refactored)
@@ -110,7 +110,7 @@
     nchunks = nsize/size
     
     if nchunks!=0:
-        for pool in xrange(npool):
+        for pool in range(npool):
             chunk_s,chunk_e = load_balancing(npool,pool,nchunks)
 
             if rank==sroot:
@@ -150,7 +150,7 @@
     nchunks = nsize/size
     
     if nchunks!=0:
-        for pool in xrange(npool):
+        for pool in range(npool):
             chunk_s,chunk_e = load_balancing(npool,pool,nchunks)
 
             if rank==sroot:
@@ -172,7 +172,7 @@
 
 def gather_scatter(arr,scatter_axis,npool):
     #scatter indices for scatter_axis to each proc
-    axis_ind = np.array(xrange(arr.shape[scatter_axis]),dtype=int)
+    axis_ind = np.array(range(arr.shape[scatter_axis]),dtype=int)
     axis_ind = scatter_full(axis_ind,npool)
 
     #broadcast indices that for scattered array to proc with rank 'r'
@@ -195,7 +195,7 @@
     start = end - size_r
     size_r = None
     
-    for r in xrange(size):
+    for r in range(size):
         comm.Barrier()
         #gather array from each proc with indices for each proc on scatter_axis
         if r==rank:
--- PAOFLOW/src/defs/constants.py	(original)
+++ PAOFLOW/src/defs/constants.py	(refactored)
@@ -54,11 +54,11 @@
 
 # Logos
 PAO = 'PAO'
-p = u"\u03C0"
+p = "\u03C0"
 pp = p.encode('utf8')
 PAOPY = str(PAO)+str(pp)
 
-C = u"\u00A9"
+C = "\u00A9"
 CC = C.encode('utf8')
 
 LL = ['x','y','z']
--- PAOFLOW/src/defs/do_Berry_conductivity.py	(original)
+++ PAOFLOW/src/defs/do_Berry_conductivity.py	(refactored)
@@ -79,13 +79,13 @@
 
 
     # Collapsing the sum over k points
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m != n:
                 E_diff_nm[:,n,m] = (E_k[:,n,ispin]-E_k[:,m,ispin])**2
                 f_nm[:,n,m]      = (fn[:,n] - fn[:,m])*np.imag(pksp[:,jpol,n,m,0]*pksp[:,ipol,m,n,0])
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing!=None:
             sigxy[e] = np.sum(1.0/(E_diff_nm[:,:,:]-(ene[e]+1.0j*deltak2[:,:,:,ispin])**2+eps)*f_nm[:,:,:])
         else:
--- PAOFLOW/src/defs/do_Berry_curvature.py	(original)
+++ PAOFLOW/src/defs/do_Berry_curvature.py	(refactored)
@@ -9,7 +9,7 @@
 # in the root directory of the present distribution,
 # or http://www.gnu.org/copyleft/gpl.txt .
 #
-from __future__ import print_function
+
 from scipy import fftpack as FFT
 import numpy as np
 import cmath
@@ -43,8 +43,8 @@
 
     deltap = 0.05
 
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m!= n:
                 Om_znk[:,n] += -2.0*np.imag(pksp[:,ipol,n,m,0]*pksp[:,jpol,m,n,0]) / \
                 ((E_k[:,m,0] - E_k[:,n,0])**2 + deltap**2)
@@ -54,7 +54,7 @@
 
     Om_zkaux = np.zeros((pksp.shape[0],ene.size),dtype=float)
 
-    for i in xrange(ene.size):
+    for i in range(ene.size):
         if smearing == 'gauss':
             Om_zkaux[:,i] = np.sum(Om_znk[:,:]*intgaussian(E_k[:,:,0],ene[i],deltak[:,:,0]),axis=1)
         elif smearing == 'm-p':
@@ -83,7 +83,7 @@
 
     n0 = 0
     if rank == 0:
-        for i in xrange(ene.size-1):
+        for i in range(ene.size-1):
             if ene[i] <= fermi_dw and ene[i+1] >= fermi_dw:
                 n0 = i
             if ene[i] <= fermi_up and ene[i+1] >= fermi_up:
--- PAOFLOW/src/defs/do_Boltz_tensors.py	(original)
+++ PAOFLOW/src/defs/do_Boltz_tensors.py	(refactored)
@@ -85,9 +85,9 @@
 
 
     if smearing == None:
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             Eaux = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T - ene
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 if smearing == None:
@@ -97,10 +97,10 @@
 
     if smearing == 'gauss':
         om = ((ene*np.ones((E_k.shape[0],ene.size),dtype=float)).T).T
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             eig = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
             delk = (deltak[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 L[i,j,:] += np.sum((kq_wght[0]*velkp[:,i,n,ispin]*velkp[:,j,n,ispin] * \
@@ -109,10 +109,10 @@
 
     if smearing == 'm-p': 
         om = ((ene*np.ones((E_k.shape[0],ene.size),dtype=float)).T).T
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             eig = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
             delk = (deltak[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 L[i,j,:] += np.sum((kq_wght[0]*velkp[:,i,n,ispin]*velkp[:,j,n,ispin] * \
--- PAOFLOW/src/defs/do_adaptive_smearing.py	(original)
+++ PAOFLOW/src/defs/do_adaptive_smearing.py	(refactored)
@@ -47,9 +47,9 @@
     deltakp2 = np.zeros((pksp.shape[0],nawf,nawf,nspin),dtype=float)
 
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         deltakp[:,n] = LAN.norm(np.real(pksaux[:,:,n]),axis=1)
-        for m in xrange(nawf):
+        for m in range(nawf):
             deltakp2[:,n,m,:] = LAN.norm(pksaux[:,:,n,:] - pksaux[:,:,m,:],axis=1)
 
     pksaux=None
--- PAOFLOW/src/defs/do_bands_calc.py	(original)
+++ PAOFLOW/src/defs/do_bands_calc.py	(refactored)
@@ -54,8 +54,8 @@
     E_kp_aux = np.zeros((kq_aux.shape[1],nawf,nspin),dtype=float,order="C")
     v_kp_aux = np.zeros((kq_aux.shape[1],nawf,nawf,nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
-        for ik in xrange(kq_aux.shape[1]):
+    for ispin in range(nspin):
+        for ik in range(kq_aux.shape[1]):
             if read_S:
                 E_kp_aux[ik,:,ispin],v_kp_aux[ik,:,:,ispin] = LAN.eigh(Hks_aux[:,:,ik,ispin], 
                                                                        b=Sks_aux[:,:,ik],lower=False, 
@@ -83,9 +83,9 @@
     comm.Barrier()
   
     if rank==0:
-        for ispin in xrange(nspin):
+        for ispin in range(nspin):
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(kq.shape[1]):
+            for ik in range(kq.shape[1]):
                 s="%d\t"%ik
                 for  j in E_kp[ik,:,ispin]:s += "% 3.5f\t"%j
                 s+="\n"
@@ -105,7 +105,7 @@
 
     auxh = np.zeros((nawf,nawf,kq.shape[1],nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         auxh[:,:,:,ispin]=np.tensordot(HRaux[:,:,:,ispin],kdot,axes=([2],[0]))
 
     kdot  = None
@@ -117,10 +117,10 @@
     nsize = kq.shape[1]
     auxs  = np.zeros((nawf,nawf,nsize),dtype=complex)
 
-    for ik in xrange(kq.shape[1]):
-        for i in xrange(nk1):
-            for j in xrange(nk2):
-                for k in xrange(nk3):
+    for ik in range(kq.shape[1]):
+        for i in range(nk1):
+            for j in range(nk2):
+                for k in range(nk3):
                     phase=R_wght[idx[i,j,k]]*cmath.exp(2.0*np.pi*kq[:,ik].dot(R[idx[i,j,k],:])*1j)
                     auxs[:,:,ik] += SRaux[:,:,i,j,k]*phase
 
--- PAOFLOW/src/defs/do_bands_calc_1D.py	(original)
+++ PAOFLOW/src/defs/do_bands_calc_1D.py	(refactored)
@@ -29,19 +29,19 @@
 
     # Count points along symmetry direction
     nL = 0
-    for ik1 in xrange(nk1):
-        for ik2 in xrange(nk2):
-            for ik3 in xrange(nk3):
+    for ik1 in range(nk1):
+        for ik2 in range(nk2):
+            for ik3 in range(nk3):
                 nL += 1
 
     Hkaux  = np.zeros((nawf,nawf,nL,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 nL=0
-                for ik1 in xrange(nk1):
-                    for ik2 in xrange(nk2):
-                        for ik3 in xrange(nk3):
+                for ik1 in range(nk1):
+                    for ik2 in range(nk2):
+                        for ik3 in range(nk3):
                             Hkaux[i,j,nL,ispin]=Hksp[i,j,ik1,ik2,ik3,ispin]
                             nL += 1
 
@@ -49,24 +49,24 @@
     # k to R
     npad = 500
     HRaux  = np.zeros((nawf,nawf,nL,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 HRaux[i,j,:,ispin] = FFT.ifft(Hkaux[i,j,:,ispin])
 
     Hkaux = None
     Hkaux  = np.zeros((nawf,nawf,npad+nL,nspin),dtype=complex)
     HRauxp  = np.zeros((nawf,nawf,npad+nL,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 HRauxp[i,j,:(nL/2),ispin]=HRaux[i,j,:(nL/2),ispin]
                 HRauxp[i,j,(npad+nL/2):,ispin]=HRaux[i,j,(nL/2):,ispin]
                 Hkaux[i,j,:,ispin] = FFT.fft(HRauxp[i,j,:,ispin])
 
     # Print PAO eigenvalues on interpolated mesh
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         write_PAO_eigs(Hkaux,ispin,inputpath)
 
     return()
--- PAOFLOW/src/defs/do_dos_calc.py	(original)
+++ PAOFLOW/src/defs/do_dos_calc.py	(refactored)
@@ -41,7 +41,7 @@
 
     dosaux=np.zeros((ene.size),order="C")
 
-    for ne in xrange(ene.size):
+    for ne in range(ene.size):
         dosaux[ne] = np.sum(np.exp(-((ene[ne]-eig)/delta)**2))
 
     comm.Barrier()
@@ -52,7 +52,7 @@
     if rank == 0:
         dos *= float(nawf)/float(netot)*1.0/np.sqrt(np.pi)/delta
         f=open(os.path.join(inputpath,'dos_'+str(ispin)+'.dat'),'w')
-        for ne in xrange(ene.size):
+        for ne in range(ene.size):
             f.write('%.5f  %.5f \n' %(ene[ne],dos[ne]))
         f.close()
 
--- PAOFLOW/src/defs/do_dos_calc_adaptive.py	(original)
+++ PAOFLOW/src/defs/do_dos_calc_adaptive.py	(refactored)
@@ -37,7 +37,7 @@
     dos = np.zeros((ene.size),dtype=float)
     dosaux = np.zeros((ene.size),dtype=float)
 
-    for ne in xrange(ene.size):
+    for ne in range(ene.size):
         if smearing == 'gauss':
             # adaptive Gaussian smearing
             dosaux[ne] = np.sum(gaussian(ene[ne],eig,delta))
@@ -52,7 +52,7 @@
     if rank == 0:
         dos *= float(nawf)/float(netot)
         f=open(os.path.join(inputpath,'dosdk_'+str(ispin)+'.dat'),'w')
-        for ne in xrange(ene.size):
+        for ne in range(ene.size):
             f.write('%.5f  %.5f \n' %(ene[ne],dos[ne]))
         f.close()
 
--- PAOFLOW/src/defs/do_double_grid.py	(original)
+++ PAOFLOW/src/defs/do_double_grid.py	(refactored)
@@ -72,16 +72,16 @@
 
     Hk_aux  = np.zeros((HR_aux.shape[0],nk1p,nk2p,nk3p,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         if not scipyfft:
-            for i in xrange(nawf):
-                for j in xrange(nawf):
+            for i in range(nawf):
+                for j in range(nawf):
                     aux = zero_pad(H_aux[i,j,:,:,:,ispin],nk1,nk2,nk3,nfft1,nfft2,nfft3)
                     fft = pyfftw.FFTW(aux,Hksp[:,:,:,i,j,ispin], axes=(0,1,2), direction='FFTW_FORWARD',\
                         flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                     Hk_aux[:,:,:,i,j,ispin] = fft()
         else:
-            for n in xrange(HR_aux.shape[0]):
+            for n in range(HR_aux.shape[0]):
                 Hk_aux[n,:,:,:,ispin] = FFT.fftn(zero_pad(HR_aux[n,:,:,:,ispin],
                                                           nk1,nk2,nk3,nfft1,nfft2,nfft3))
 
--- PAOFLOW/src/defs/do_eigh_calc.py	(original)
+++ PAOFLOW/src/defs/do_eigh_calc.py	(refactored)
@@ -47,7 +47,7 @@
     E_kp = np.zeros((nkpi,nawf,nspin),dtype=float)
     v_kp = np.zeros((nkpi,nawf,nawf,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         for ik in range(nkpi):
             if read_S:
                 E_kp[ik,:,ispin],v_kp[ik,:,:,ispin] = LA.eigh(Hks_int[:,:,ik,ispin],Sks_int[:,:,ik])
@@ -69,8 +69,8 @@
     auxh = np.zeros((nawf,nawf,nkpi,nspin),dtype=complex)
     HRaux = np.reshape(HRaux,(nawf,nawf,nk1*nk2*nk3,nspin),order='C')
 
-    for ik in xrange(nkpi):
-        for ispin in xrange(nspin):
+    for ik in range(nkpi):
+        for ispin in range(nspin):
              auxh[:,:,ik,ispin] = np.sum(HRaux[:,:,:,ispin]*np.exp(2.0*np.pi*kq[ik,:].dot(R[:,:].T)*1j),axis=2)
 
     return(auxh)
@@ -79,10 +79,10 @@
 
     auxs = np.zeros((nawf,nawf,nkpi),dtype=complex)
 
-    for ik in xrange(nkpi):
-        for i in xrange(nk1):
-            for j in xrange(nk2):
-                for k in xrange(nk3):
+    for ik in range(nkpi):
+        for i in range(nk1):
+            for j in range(nk2):
+                for k in range(nk3):
                     phase=R_wght[idx[i,j,k]]*cmath.exp(2.0*np.pi*kq[ik,:].dot(R[idx[i,j,k],:])*1j)
                     auxs[:,:,ik] += SRaux[:,:,i,j,k]*phase
 
--- PAOFLOW/src/defs/do_epsilon.py	(original)
+++ PAOFLOW/src/defs/do_epsilon.py	(refactored)
@@ -101,9 +101,9 @@
     eps=1.e-8
     fnF = np.zeros((pksp.shape[0]),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
                 np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((pksp.shape[0],ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -114,7 +114,7 @@
                            kq_wght[0] /delta * dfunc * ((fn - fm)*np.ones((pksp.shape[0],ene.size),dtype=float).T).T).T* \
                            1.0),axis=1)
             if metal and n == m:
-                for ik in xrange(pksp.shape[0]):
+                for ik in range(pksp.shape[0]):
                     try:
                         fnF[ik] = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[ik,n,ispin]/temp))
                     except:
@@ -137,7 +137,7 @@
     effterm = np.zeros((pksp.shape[0],nawf),dtype=complex)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -146,7 +146,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -213,7 +213,7 @@
     # gaussian smearing
 
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing=='gauss':
             np.exp(-((ene[e]-E_diff_nm)/dk2_nm)**2,out=dfunc)
             dfunc *= sq2_dk2
@@ -244,7 +244,7 @@
 
 
 
-        for e in xrange(ene.size):
+        for e in range(ene.size):
             if smearing=='gauss':
                 np.exp(-((ene[e])/dk_cont)**2,out=dfunc)
                 dfunc *= sq2_dk1
@@ -273,7 +273,7 @@
     if ini_ie < 3: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
     f_ene = intmetpax(ene,shift,1.0)
-    for ie in xrange(ini_ie,end_ie):
+    for ie in range(ini_ie,end_ie):
         #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
         #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
         epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]*f_ene[1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_epsilon_d2.py	(original)
+++ PAOFLOW/src/defs/do_epsilon_d2.py	(refactored)
@@ -116,13 +116,13 @@
 
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
         try:
             fnF = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[:,n,ispin]/temp))
         except:
             fnF = 1.0e8*np.ones(end_ik-ini_ik,dtype=float)
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
                 np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((end_ik-ini_ik,ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -149,7 +149,7 @@
     effterm = np.zeros((end_ik-ini_ik,nawf),dtype=complex)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -158,7 +158,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -182,7 +182,7 @@
                                (pksp[:,ipol,n,m,ispin] * pksp[:,jpol,m,n,ispin]),axis=1))
     if metal:
         sum_rule = 0.0
-        for n in xrange(nawf):
+        for n in range(nawf):
             if smearing == 'gauss':
                 fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             elif smearing == 'm-p':
@@ -196,7 +196,7 @@
                            kq_wght[0] * (fn*np.ones((end_ik-ini_ik,ene.size),dtype=float).T).T).T * \
                            (effterm[:,n]),axis=1))
             sum_rule += np.sum(fn*tksp[:,ipol,jpol,n,n,ispin])
-        if rank == 0: print('f-sum rule = ',sum_rule)
+        if rank == 0: print(('f-sum rule = ',sum_rule))
 
     epsr *= 4.0/(EPS0 * EVTORY * omega)
 
@@ -211,7 +211,7 @@
     Ef = 0.0
     deltat = 0.1
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             if metal: fnF = gaussian(E_k[:,n,ispin],Ef,0.03*deltak[:,n,ispin])
@@ -220,7 +220,7 @@
             if metal: fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -269,7 +269,7 @@
     if ini_ie == 0: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
     f_ene = intmetpax(ene,shift,1.0)
-    for ie in xrange(ini_ie,end_ie):
+    for ie in range(ini_ie,end_ie):
         #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
         #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
         epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]*f_ene[1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_epsilon_old.py	(original)
+++ PAOFLOW/src/defs/do_epsilon_old.py	(refactored)
@@ -96,10 +96,10 @@
 
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
         fnF = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[:,n,ispin]/temp))
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
             np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((end_ik-ini_ik,ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -122,7 +122,7 @@
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -131,7 +131,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,n,ispin])
             elif smearing == 'm-p':
@@ -181,9 +181,9 @@
 
     if ini_ie == 0: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
-    for ie in xrange(ini_ie,end_ie):
-        for i in xrange(3):
-            for j in xrange(3):
+    for ie in range(ini_ie,end_ie):
+        for i in range(3):
+            for j in range(3):
                 #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
                 #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
                 epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_fermisurf.py	(original)
+++ PAOFLOW/src/defs/do_fermisurf.py	(refactored)
@@ -58,7 +58,7 @@
 
         write2bxsf(fermi_dw,fermi_up,eigband, nk1, nk2, nk3, icount, ind_plot, Efermi, alat,x0, b_vectors, 'FermiSurf_'+str(ispin)+'.bxsf',inputpath)   
 
-        for ib in xrange(icount):
+        for ib in range(icount):
             np.savez(os.path.join(inputpath,'Fermi_surf_band_'+str(ib)), nameband = eigband[:,:,:,ib])
 
 
--- PAOFLOW/src/defs/do_gradient.py	(original)
+++ PAOFLOW/src/defs/do_gradient.py	(refactored)
@@ -69,19 +69,19 @@
     ### real space grid replaces k space ###
     ########################################
     if using_cuda:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 Hksp[n,:,:,:,ispin] = cuda_ifftn(Hksp[n,:,:,:,ispin])
 
     elif scipyfft:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 Hksp[n,:,:,:,ispin] = FFT.ifftn(Hksp[n,:,:,:,ispin],axes=(0,1,2))
                 Hksp[n,:,:,:,ispin] = FFT.fftshift(Hksp[n,:,:,:,ispin],axes=(0,1,2))
 
     else:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 fft = pyfftw.FFTW(Hksp[n,:,:,:,ispin],Hksp[n,:,:,:,ispin],axes=(0,1,2),
                                   direction='FFTW_BACKWARD',flags=('FFTW_MEASURE', ),
                                   threads=nthread, planning_timelimit=None )
@@ -100,8 +100,8 @@
     dHksp = np.zeros((num_n,nk1*nk2*nk3,3,nspin),dtype=complex,order='C')
 
     # Compute R*H(R)
-    for ispin in xrange(nspin):
-        for l in xrange(3):
+    for ispin in range(nspin):
+        for l in range(3):
             dHksp[:,:,l,ispin] = 1.0j*alat*Rfft[:,l]*Hksp[...,ispin]
 
     Hksp=None
@@ -110,15 +110,15 @@
     # Compute dH(k)/dk
 
     if scipyfft:
-        for n in xrange(dHksp.shape[0]):
-            for l in xrange(dHksp.shape[4]):
-                for ispin in xrange(dHksp.shape[5]):
+        for n in range(dHksp.shape[0]):
+            for l in range(dHksp.shape[4]):
+                for ispin in range(dHksp.shape[5]):
                     dHksp[n,:,:,:,l,ispin] = FFT.fftn(dHksp[n,:,:,:,l,ispin],axes=(0,1,2),)
 
     else:
-        for n in xrange(dHksp.shape[0]):
-            for l in xrange(dHksp.shape[4]):
-                for ispin in xrange(dHksp.shape[5]):
+        for n in range(dHksp.shape[0]):
+            for l in range(dHksp.shape[4]):
+                for ispin in range(dHksp.shape[5]):
                     fft = pyfftw.FFTW(dHksp[n,:,:,:,l,ispin]
                                       ,dHksp[n,:,:,:,l,ispin],axes=(0,1,2),
                                       direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ),
--- PAOFLOW/src/defs/do_gradient_d2.py	(original)
+++ PAOFLOW/src/defs/do_gradient_d2.py	(refactored)
@@ -59,9 +59,9 @@
             Hksp = None
         else:
             HRaux  = np.zeros_like(Hksp)
-            for ispin in xrange(nspin):
-                for n in xrange(nawf):
-                    for m in xrange(nawf):
+            for ispin in range(nspin):
+                for n in range(nawf):
+                    for m in range(nawf):
                         fft = pyfftw.FFTW(Hksp[:,:,:,n,m,ispin],HRaux[:,:,:,n,m,ispin],axes=(0,1,2), direction='FFTW_BACKWARD',\
                               flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                         HRaux[:,:,:,n,m,ispin] = fft()
@@ -81,7 +81,7 @@
         dHRaux  = None
         d2HRaux  = None
 
-    for pool in xrange(npool):
+    for pool in range(npool):
         ini_ip, end_ip = load_balancing(npool,pool,nktot)
         nkpool = end_ip - ini_ip
 
@@ -102,12 +102,12 @@
         Rfftaux = scatter_array(Rfft_split)
 
         # Compute R*H(R)
-        for l in xrange(3):
-            for ispin in xrange(nspin):
-                for n in xrange(nawf):
-                    for m in xrange(nawf):
+        for l in range(3):
+            for ispin in range(nspin):
+                for n in range(nawf):
+                    for m in range(nawf):
                         dHRaux1[:,l,n,m,ispin] = 1.0j*alat*Rfftaux[:,l]*HRaux1[:,n,m,ispin]
-                        for lp in xrange(3):
+                        for lp in range(3):
                             d2HRaux1[:,l,lp,n,m,ispin] = -1.0*alat**2*Rfftaux[:,l]*Rfftaux[:,lp]*HRaux1[:,n,m,ispin]
 
         gather_array(dHRaux_split, dHRaux1)
@@ -126,20 +126,20 @@
         if scipyfft:
             dHksp  = np.zeros((nk1,nk2,nk3,3,nawf,nawf,nspin),dtype=complex)
             d2Hksp  = np.zeros((nk1,nk2,nk3,3,3,nawf,nawf,nspin),dtype=complex)
-            for l in xrange(3):
+            for l in range(3):
                 dHksp[:,:,:,l,:,:,:] = FFT.fftn(dHRaux[:,:,:,l,:,:,:],axes=[0,1,2])
-                for lp in xrange(3):
+                for lp in range(3):
                     d2Hksp[:,:,:,l,lp,:,:,:] = FFT.fftn(d2HRaux[:,:,:,l,lp,:,:,:],axes=[0,1,2])
             dHraux = None
         else:
-            for l in xrange(3):
-                for ispin in xrange(nspin):
-                    for n in xrange(nawf):
-                        for m in xrange(nawf):
+            for l in range(3):
+                for ispin in range(nspin):
+                    for n in range(nawf):
+                        for m in range(nawf):
                             fft = pyfftw.FFTW(dHRaux[:,:,:,l,n,m,ispin],dHksp[:,:,:,l,n,m,ispin],axes=(0,1,2), \
                             direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                             dHksp[:,:,:,l,n,m,ispin] = fft()
-                            for lp in xrange(3):
+                            for lp in range(3):
                                 fft = pyfftw.FFTW(d2HRaux[:,:,:,l,lp,n,m,ispin],d2Hksp[:,:,:,l,lp,n,m,ispin],axes=(0,1,2), \
                                 direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                                 d2Hksp[:,:,:,l,lp,n,m,ispin] = fft()
--- PAOFLOW/src/defs/do_momentum.py	(original)
+++ PAOFLOW/src/defs/do_momentum.py	(refactored)
@@ -35,17 +35,17 @@
 
 
 
-    for ik in xrange(dHksp.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(dHksp.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 pksp[ik,l,:,:,ispin] = dHksp[ik,l,:,:,ispin].dot(vec[ik,:,:,ispin])
 
 
     vec_cross = np.ascontiguousarray(np.conj(np.swapaxes(vec,1,2)))
 
-    for ik in xrange(dHksp.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(dHksp.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 pksp[ik,l,:,:,ispin] = vec_cross[ik,:,:,ispin].dot(pksp[ik,l,:,:,ispin])
 
     comm.Barrier()
--- PAOFLOW/src/defs/do_momentum_d2.py	(original)
+++ PAOFLOW/src/defs/do_momentum_d2.py	(refactored)
@@ -49,7 +49,7 @@
         pksp = None
         tksp = None
 
-    for pool in xrange(npool):
+    for pool in range(npool):
         ini_ip, end_ip = load_balancing(npool, pool, nktot)
         nkpool = end_ip - ini_ip 
 
@@ -72,12 +72,12 @@
         tksaux = scatter_array(tks_split)
         vecaux = scatter_array(vec_split)
 
-        for ik in xrange(nsize):
-            for ispin in xrange(nspin):
-                for l in xrange(3):
+        for ik in range(nsize):
+            for ispin in range(nspin):
+                for l in range(3):
                     pksaux[ik,l,:,:,ispin] = np.conj(vecaux[ik,:,:,ispin].T).dot \
                                 (dHkaux[ik,l,:,:,ispin]).dot(vecaux[ik,:,:,ispin])
-                    for lp in xrange(3):
+                    for lp in range(3):
                         tksaux[ik,l,lp,:,:,ispin] = np.conj(vecaux[ik,:,:,ispin].T).dot \
                                     (d2Hkaux[ik,l,lp,:,:,ispin]).dot(vecaux[ik,:,:,ispin])
 
--- PAOFLOW/src/defs/do_non_ortho.py	(original)
+++ PAOFLOW/src/defs/do_non_ortho.py	(refactored)
@@ -22,12 +22,12 @@
 
     nawf,_,nkpnts,nspin = Hks.shape
     S2k  = np.zeros((nawf,nawf,nkpnts),dtype=complex)
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         S2k[:,:,ik] = LA.sqrtm(Sks[:,:,ik])
 
     Hks_no = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             Hks_no[:,:,ik,ispin] = np.dot(S2k[:,:,ik],Hks[:,:,ik,ispin]).dot(S2k[:,:,ik])
 
     return(Hks_no)
--- PAOFLOW/src/defs/do_ortho.py	(original)
+++ PAOFLOW/src/defs/do_ortho.py	(refactored)
@@ -21,12 +21,12 @@
 
     nawf,_,nkpnts,nspin = Hks.shape
     S2k  = np.zeros((nawf,nawf,nkpnts),dtype=complex)
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         S2k[:,:,ik] = LAN.inv(LA.sqrtm(Sks[:,:,ik]))
 
     Hks_o = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             Hks_o[:,:,ik,ispin] = np.dot(S2k[:,:,ik],Hks[:,:,ik,ispin]).dot(S2k[:,:,ik])
 
     return(Hks_o)
--- PAOFLOW/src/defs/do_spin_Berry_curvature.py	(original)
+++ PAOFLOW/src/defs/do_spin_Berry_curvature.py	(refactored)
@@ -46,8 +46,8 @@
 
 
     deltap = 0.05
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m!= n:
                 Om_znkaux[:,n] += -2.0*np.imag(jksp[:,ipol,n,m,0]*pksp[:,jpol,m,n,0]) / \
                 ((E_k[:,m,0] - E_k[:,n,0])**2 + deltap**2)
@@ -64,7 +64,7 @@
 
     Om_zkaux = np.zeros((pksp.shape[0],ene.size),dtype=float)
 
-    for i in xrange(ene.size):
+    for i in range(ene.size):
         if smearing == 'gauss':
             Om_zkaux[:,i] = np.sum(Om_znkaux[:,:]*intgaussian(E_k[:,:,0],ene[i],deltak[:,:,0]),axis=1)
         elif smearing == 'm-p':
@@ -86,7 +86,7 @@
     n0 = 0
     if rank == 0:
         Om_k = np.zeros((nk1,nk2,nk3,ene.size),dtype=float)
-        for i in xrange(ene.size-1):
+        for i in range(ene.size-1):
             if ene[i] <= fermi_dw and ene[i+1] >= fermi_dw:
                 n0 = i
             if ene[i] <= fermi_up and ene[i+1] >= fermi_up:
--- PAOFLOW/src/defs/do_spin_Hall_conductivity.py	(original)
+++ PAOFLOW/src/defs/do_spin_Hall_conductivity.py	(refactored)
@@ -79,15 +79,15 @@
         fn = intmetpax(E_k[:,:,0],Ef,deltak[:,:,0]) 
 
     # Collapsing the sum over k points
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m != n:
                 E_diff_nm[:,n,m] = (E_k[:,n,ispin]-E_k[:,m,ispin])**2
                 f_nm[:,n,m]      = (fn[:,n] - fn[:,m])*np.imag(jksp[:,jpol,n,m,0]*pksp[:,ipol,m,n,0])
 
     fn = None
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing!=None:
             sigxy[e] = np.sum(1.0/(E_diff_nm[:,:,:]-(ene[e]+1.0j*deltak2[:,:,:,ispin])**2+eps)*f_nm[:,:,:])
         else:
--- PAOFLOW/src/defs/do_spin_current.py	(original)
+++ PAOFLOW/src/defs/do_spin_current.py	(refactored)
@@ -38,10 +38,10 @@
     if spin_orbit:
         # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
         Sj = np.zeros((nawf,nawf),dtype=complex)
-        for i in xrange(nawf/2):
+        for i in range(nawf/2):
             Sj[i,i] = sP[spol][0,0]
             Sj[i,i+1] = sP[spol][0,1]
-        for i in xrange(nawf/2,nawf):
+        for i in range(nawf/2,nawf):
             Sj[i,i-1] = sP[spol][1,0]
             Sj[i,i] = sP[spol][1,1]
     else:
@@ -54,18 +54,18 @@
 
 
 
-    for ik in xrange(dHksp.shape[0]):
-        for l in xrange(3):
-            for ispin in xrange(nspin):
+    for ik in range(dHksp.shape[0]):
+        for l in range(3):
+            for ispin in range(nspin):
                 jdHksp[ik,l,:,:,ispin] = \
                     0.5*(np.dot(Sj,dHksp[ik,l,:,:,ispin])+np.dot(dHksp[ik,l,:,:,ispin],Sj))
                 
 
     jksp = np.zeros((dHksp.shape[0],3,bnd,bnd,nspin),dtype=complex)
 
-    for ik in xrange(dHksp.shape[0]):
-        for l in xrange(3):            
-            for ispin in xrange(nspin):
+    for ik in range(dHksp.shape[0]):
+        for l in range(3):            
+            for ispin in range(nspin):
 
                 jksp[ik,l,:,:,ispin] = np.conj(vec[ik,:,:,ispin].T).dot \
                             (jdHksp[ik,l,:,:,ispin]).dot(vec[ik,:,:,ispin])[:bnd,:bnd]
--- PAOFLOW/src/defs/do_spin_orbit.py	(original)
+++ PAOFLOW/src/defs/do_spin_orbit.py	(refactored)
@@ -43,7 +43,7 @@
 
     M=9
     nt=natoms
-    for n in xrange(nt):
+    for n in range(nt):
         i=n*M
         j=(n+1)*M
         # Up-Up
--- PAOFLOW/src/defs/do_spin_texture.py	(original)
+++ PAOFLOW/src/defs/do_spin_texture.py	(refactored)
@@ -55,17 +55,17 @@
     if spin_orbit:
         # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
         Sj = np.zeros((3,nawf,nawf),dtype=complex)
-        for spol in xrange(3):
-            for i in xrange(nawf/2):
+        for spol in range(3):
+            for i in range(nawf/2):
                 Sj[spol,i,i] = sP[spol][0,0]
                 Sj[spol,i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[spol,i,i-1] = sP[spol][1,0]
                 Sj[spol,i,i] = sP[spol][1,1]
     else:
         # Spin operator matrix  in the basis of |j,m_j,l,s> (full SO)
         Sj = np.zeros((3,nawf,nawf),dtype=complex)
-        for spol in xrange(3):
+        for spol in range(3):
             Sj[spol,:,:] = clebsch_gordan(nawf,sh,nl,spol)
 
     # Compute matrix elements of the spin operator
@@ -75,9 +75,9 @@
 
     sktxtaux = np.zeros((vec.shape[0],3,nawf,nawf),dtype=complex)
 
-    for ik in xrange(vec.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(vec.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 sktxtaux[ik,l,:,:] = np.conj(vec[ik,:,:,ispin].T).dot \
                             (Sj[l,:,:]).dot(vec[ik,:,:,ispin])
 
@@ -87,7 +87,7 @@
     if rank == 0:
         sktxt = np.reshape(sktxt,(nk1,nk2,nk3,3,nawf,nawf),order='C')
 
-        for ib in xrange(icount):
+        for ib in range(icount):
             np.savez(os.path.join(inputpath,'spin_text_band_'+str(ib)), spinband = sktxt[:,:,:,:,ind_plot[ib],ind_plot[ib]])
 
     sktxt = None
--- PAOFLOW/src/defs/do_topology_calc.py	(original)
+++ PAOFLOW/src/defs/do_topology_calc.py	(refactored)
@@ -60,11 +60,11 @@
         # Define time reversal operator
         theta = -1.0j*clebsch_gordan(nawf,sh,nl,1)
         wl = np.zeros((nktrim/2,nawf,nawf),dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             wl[ik,:,:] = np.conj(v_ktrim[ik,:,:,0].T).dot(theta).dot(np.conj(v_ktrim[ik+nktrim/2,:,:,0]))
             wl[ik,:,:] = wl[ik,:,:]-wl[ik,:,:].T  # enforce skew symmetry
         delta_ik = np.zeros(nktrim/2,dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             delta_ik[ik] = pf.pfaffian(wl[ik,:nelec,:nelec])/np.sqrt(LAN.det(wl[ik,:nelec,:nelec]))
 
         f=open(inputpath+'Z2'+'.dat','w')
@@ -105,10 +105,10 @@
     Rfft = np.reshape(Rfft,(nk1*nk2*nk3,3),order='C')
     HRs = np.reshape(HRs,(nawf,nawf,nk1*nk2*nk3,nspin),order='C')
     dHRs  = np.zeros((3,nawf,nawf,nk1*nk2*nk3,nspin),dtype=complex)
-    for l in xrange(3):
-        for ispin in xrange(nspin):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+    for l in range(3):
+        for ispin in range(nspin):
+            for n in range(nawf):
+                for m in range(nawf):
                     dHRs[l,n,m,:,ispin] = 1.0j*alat*ANGSTROM_AU*Rfft[:,l]*HRs[n,m,:,ispin]
 
     # Compute dH(k)/dk on the path
@@ -132,9 +132,9 @@
 
     # Compute momenta
     pks = np.zeros((nkpi,3,nawf,nawf,nspin),dtype=complex)
-    for ik in xrange(nkpi):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(nkpi):
+        for ispin in range(nspin):
+            for l in range(3):
                 pks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                             (dHks[l,:,:,ik,ispin]).dot(v_kp[ik,:,:,ispin])
 
@@ -150,10 +150,10 @@
         if spin_orbit:
             # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
             Sj = np.zeros((nawf,nawf),dtype=complex)
-            for i in xrange(nawf/2):
+            for i in range(nawf/2):
                 Sj[i,i] = sP[spol][0,0]
                 Sj[i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[i,i-1] = sP[spol][1,0]
                 Sj[i,i] = sP[spol][1,1]
         else:
@@ -162,9 +162,9 @@
 
         #jdHks = np.zeros((3,nawf,nawf,nkpi,nspin),dtype=complex)
         jks = np.zeros((nkpi,3,nawf,nawf,nspin),dtype=complex)
-        for ik in xrange(nkpi):
-            for ispin in xrange(nspin):
-                for l in xrange(3):
+        for ik in range(nkpi):
+            for ispin in range(nspin):
+                for l in range(3):
                     jks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                                 (0.5*(np.dot(Sj,dHks[l,:,:,ik,ispin])+np.dot(dHks[l,:,:,ik,ispin],Sj))).dot(v_kp[ik,:,:,ispin])
 
@@ -177,9 +177,9 @@
         mu = -0.2 # chemical potential in eV)
         Om_znk = np.zeros((nkpi,nawf),dtype=float)
         Om_zk = np.zeros((nkpi),dtype=float)
-        for ik in xrange(nkpi):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+        for ik in range(nkpi):
+            for n in range(nawf):
+                for m in range(nawf):
                     if m!= n:
                         if Berry:
                             Om_znk[ik,n] += -1.0*np.imag(pks[ik,jpol,n,m,0]*pks[ik,ipol,m,n,0]-pks[ik,ipol,n,m,0]*pks[ik,jpol,m,n,0]) / \
@@ -193,24 +193,24 @@
     if rank == 0:
         if Berry:
             f=open(inputpath+'Omega_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat','w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,-Om_zk[ik]))
             f.close()
         if spin_Hall:
             f=open(inputpath+'Omegaj_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat','w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,Omj_zk[ik]))
             f.close()
 
     if rank == 0:
         if spin_orbit: bnd *= 2
         velk = np.zeros((nkpi,3,nawf,nspin),dtype=float)
-        for n in xrange(nawf):
+        for n in range(nawf):
             velk[:,:,n,:] = np.real(pks[:,:,n,n,:])
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+        for ispin in range(nspin):
+            for l in range(3):
                 f=open(inputpath+'velocity_'+str(l)+'_'+str(ispin)+'.dat','w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in velk[ik,l,:bnd,ispin]:s += "%3.5f\t"%j
                     s+="\n"
@@ -223,9 +223,9 @@
 
     auxh = np.zeros((3,nawf,nawf,nkpi,nspin),dtype=complex)
 
-    for ik in xrange(ini_ik,end_ik):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(ini_ik,end_ik):
+        for ispin in range(nspin):
+            for l in range(3):
                 auxh[l,:,:,ik,ispin] = np.sum(dHRaux[l,:,:,:,ispin]*np.exp(2.0*np.pi*kq[:,ik].dot(R[:,:].T)*1j),axis=2)
 
     return(auxh)
--- PAOFLOW/src/defs/do_topology_calc_new.py	(original)
+++ PAOFLOW/src/defs/do_topology_calc_new.py	(refactored)
@@ -60,11 +60,11 @@
         # Define time reversal operator
         theta = -1.0j*clebsch_gordan(nawf,sh,nl,1)
         wl = np.zeros((nktrim/2,nawf,nawf),dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             wl[ik,:,:] = np.conj(v_ktrim[ik,:,:,0].T).dot(theta).dot(np.conj(v_ktrim[ik+nktrim/2,:,:,0]))
             wl[ik,:,:] = wl[ik,:,:]-wl[ik,:,:].T  # enforce skew symmetry
         delta_ik = np.zeros(nktrim/2,dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             delta_ik[ik] = pf.pfaffian(wl[ik,:nelec,:nelec])/np.sqrt(LAN.det(wl[ik,:nelec,:nelec]))
 
         f=open(os.path.join(inputpath,'Z2'+'.dat'),'w')
@@ -123,10 +123,10 @@
         if spin_orbit:
             # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
             Sj = np.zeros((nawf,nawf),dtype=complex)
-            for i in xrange(nawf/2):
+            for i in range(nawf/2):
                 Sj[i,i] = sP[spol][0,0]
                 Sj[i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[i,i-1] = sP[spol][1,0]
                 Sj[i,i] = sP[spol][1,1]
         else:
@@ -142,11 +142,11 @@
 
 
     pks = np.zeros((kq_aux.shape[1],3,bnd,bnd,nspin),dtype=complex)
-    for l in xrange(3):
+    for l in range(3):
         dHRs  = np.zeros((HRs_aux.shape[0],nawf,nawf,nspin),dtype=complex)
-        for ispin in xrange(nspin):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+        for ispin in range(nspin):
+            for n in range(nawf):
+                for m in range(nawf):
                     dHRs[:,n,m,ispin] = 1.0j*alat*ANGSTROM_AU*Rfft_aux[:,l]*HRs_aux[:,n,m,ispin]
 
 
@@ -171,15 +171,15 @@
         dHRs = None
 
         # Compute momenta
-        for ik in xrange(dHks_aux.shape[0]):
-            for ispin in xrange(nspin):
+        for ik in range(dHks_aux.shape[0]):
+            for ispin in range(nspin):
                 pks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                     (dHks_aux[ik,:,:,ispin]).dot(v_kp[ik,:,:,ispin])[:bnd,:bnd]
 
 
         if spin_Hall:
-            for ik in xrange(pks.shape[0]):
-                for ispin in xrange(nspin):
+            for ik in range(pks.shape[0]):
+                for ispin in range(nspin):
                     jks[ik,l,:,:,ispin] = (np.conj(v_kp[ik,:,:,ispin].T).dot \
                         (0.5*(np.dot(Sj,dHks_aux[ik,:,:,ispin])+np.dot(dHks_aux[ik,:,:,ispin],Sj))).dot(v_kp[ik,:,:,ispin]))[:bnd,:bnd]
         if spin_Hall:
@@ -194,12 +194,12 @@
     if eff_mass == True: 
         tks = np.zeros((kq_aux.shape[1],3,3,bnd,bnd,nspin),dtype=complex)
 
-        for l in xrange(3):
-            for lp in xrange(3):
+        for l in range(3):
+            for lp in range(3):
                 d2HRs = np.zeros((HRs_aux.shape[0],nawf,nawf,nspin),dtype=complex)
-                for ispin in xrange(nspin):
-                    for n in xrange(nawf):
-                        for m in xrange(nawf):
+                for ispin in range(nspin):
+                    for n in range(nawf):
+                        for m in range(nawf):
                             d2HRs[:,n,m,ispin] = -1.0*alat**2*ANGSTROM_AU**2*Rfft_aux[:,l]*Rfft_aux[:,lp]*HRs_aux[:,n,m,ispin]
 
 
@@ -222,8 +222,8 @@
 
                 # Compute kinetic energy
 
-                for ik in xrange(d2Hks_aux.shape[0]):
-                    for ispin in xrange(nspin):
+                for ik in range(d2Hks_aux.shape[0]):
+                    for ispin in range(nspin):
                         tks[ik,l,lp,:,:,ispin] = (np.conj(v_kp[ik,:,:,ispin].T).dot \
                             (d2Hks_aux[ik,:,:,ispin]).dot(v_kp[ik,:,:,ispin]))[:bnd,:bnd]
 
@@ -234,10 +234,10 @@
 
         # Compute effective mass
         mkm1 = np.zeros((tks.shape[0],bnd,3,3,nspin),dtype=complex)
-        for ik in xrange(tks.shape[0]):
-            for ispin in xrange(nspin):
-                for n in xrange(bnd):
-                    for m in xrange(bnd):
+        for ik in range(tks.shape[0]):
+            for ispin in range(nspin):
+                for n in range(bnd):
+                    for m in range(bnd):
                         if m != n:
                             mkm1[ik,n,ipol,jpol,ispin] += (pks[ik,ipol,n,m,ispin]*pks[ik,jpol,m,n,ispin]+pks[ik,jpol,n,m,ispin]*pks[ik,ipol,m,n,ispin]) / \
                                                         (E_k[ik,n,ispin]-E_k[ik,m,ispin]+1.e-16)
@@ -251,9 +251,9 @@
 
         #mkm1 *= ELECTRONVOLT_SI**2/H_OVER_TPI**2*ELECTRONMASS_SI
         if rank == 0:
-            for ispin in xrange(nspin):
+            for ispin in range(nspin):
                 f=open(os.path.join(inputpath,'effmass'+'_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in np.real(mkm1[ik,:bnd,ipol,jpol,ispin]):s += "% 3.5f\t"%j
                     s+="\n"
@@ -285,9 +285,9 @@
         mu = -0.2 # chemical potential in eV)
         Om_znk = np.zeros((pks.shape[0],bnd),dtype=float)
         Om_zk = np.zeros((pks.shape[0],1),dtype=float)
-        for ik in xrange(pks.shape[0]):
-            for n in xrange(bnd):
-                for m in xrange(bnd):
+        for ik in range(pks.shape[0]):
+            for n in range(bnd):
+                for m in range(bnd):
                     if m!= n:
                         if Berry:
                             Om_znk[ik,n] += -1.0*np.imag(pks[ik,jpol,n,m,0]*pks[ik,ipol,m,n,0]-pks[ik,ipol,n,m,0]*pks[ik,jpol,m,n,0]) / \
@@ -302,14 +302,14 @@
         Om_zk = gather_full(Om_zk,npool)
         if rank == 0:
             f=open(os.path.join(inputpath,'Omega_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,-Om_zk[ik,0]))
             f.close()
     if spin_Hall:
         Omj_zk = gather_full(Omj_zk,npool)
         if rank == 0:
             f=open(os.path.join(inputpath,'Omegaj_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,Omj_zk[ik,0]))
             f.close()
 
@@ -317,12 +317,12 @@
     if rank == 0:
         if spin_orbit: bnd *= 2
         velk = np.zeros((nkpi,3,bnd,nspin),dtype=float)
-        for n in xrange(bnd):
+        for n in range(bnd):
             velk[:,:,n,:] = np.real(pks[:,:,n,n,:])
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+        for ispin in range(nspin):
+            for l in range(3):
                 f=open(os.path.join(inputpath,'velocity_'+str(l)+'_'+str(ispin)+'.dat'),'w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in velk[ik,l,:bnd,ispin]:s += "%3.5f\t"%j
                     s+="\n"
@@ -338,7 +338,7 @@
 
     auxh = np.zeros((nawf,nawf,kq.shape[1],nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         auxh[:,:,:,ispin]=np.tensordot(HRaux[:,:,:,ispin],kdot,axes=([2],[0]))
 
     kdot  = None
--- PAOFLOW/src/defs/do_z2pack.py	(original)
+++ PAOFLOW/src/defs/do_z2pack.py	(refactored)
@@ -35,7 +35,7 @@
 
     # print each cell weight
     j=0
-    for i in xrange(nlines):
+    for i in range(nlines):
         j=i*nl
         f.write ('   '.join('{:d} '.format(j) for j in kq_wght[j:j+nl]))
         f.write ('\n')
@@ -45,9 +45,9 @@
         f.write ('   '.join('{:d} '.format(j) for j in kq_wght[nlines*nl:nkpts]))
         f.write ('\n')
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
@@ -62,7 +62,7 @@
                 ix=-round(Rx*nk1,0)
                 iy=-round(Ry*nk2,0)
                 iz=-round(Rz*nk3,0)
-                for m in xrange(nawf):
-                    for l in xrange(nawf):
+                for m in range(nawf):
+                    for l in range(nawf):
                         # l+1,m+1 just to start from 1 not zero
                         f.write (('%3d %3d %3d %5d %5d %14f %14f \n') %(ix,iy,iz,l+1,m+1,HRs[l,m,i,j,k,0].real,HRs[l,m,i,j,k,0].imag))
--- PAOFLOW/src/defs/get_K_grid_fft.py	(original)
+++ PAOFLOW/src/defs/get_K_grid_fft.py	(refactored)
@@ -18,9 +18,9 @@
     K_wght /= nktot
     idk = np.zeros((nk1,nk2,nk3),dtype=int)
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
--- PAOFLOW/src/defs/get_R_grid_fft.py	(original)
+++ PAOFLOW/src/defs/get_R_grid_fft.py	(refactored)
@@ -19,9 +19,9 @@
     R_wght = np.ones((nrtot),dtype=float)
     idx = np.zeros((nk1,nk2,nk3),dtype=int)
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
--- PAOFLOW/src/defs/kpnts_interpolation_mesh.py	(original)
+++ PAOFLOW/src/defs/kpnts_interpolation_mesh.py	(refactored)
@@ -444,7 +444,7 @@
         qe_conv    = np.asarray([[ 1.0, 0.0, 0.0],[ 0.0, 1.0, 0.0],[ 0.0, 0.0, 1.0]])
                                    
 
-    for k,v in special_points.iteritems():
+    for k,v in special_points.items():
         first  = np.array(v).dot(np.linalg.inv(aflow_conv))
         if ibrav==9:
             second = qe_conv.T.dot(first)
@@ -480,9 +480,9 @@
     kq=np.copy(points)
     cart = False
     if cart:
-        for n in xrange(kq.shape[1]):
+        for n in range(kq.shape[1]):
             kq[:,n]=np.dot(kq[:,n],b_vectors)
-    for i in xrange(kq.shape[1]):
+    for i in range(kq.shape[1]):
         path_file+="%s %s %s\n"%(kq[0,i],kq[1,i],kq[2,i])
 
     if rank==0:
@@ -517,7 +517,7 @@
     if ibrav==0:
         sys.exit('IBRAV = 0 not permitted')
     if ibrav<0:
-        print('Lattice type %s is not implemented') % ibrav
+        print(('Lattice type %s is not implemented') % ibrav)
         logging.error('The ibrav value from QE has not yet been implemented')
         raise Exception
 
@@ -540,7 +540,7 @@
         point1 = None
         point2 = None
 
-        for index2 in xrange(len(a)-1):
+        for index2 in range(len(a)-1):
             try:
                 point1 = a[index2]
                 point2 = a[index2+1]
--- PAOFLOW/src/defs/load_balancing.py	(original)
+++ PAOFLOW/src/defs/load_balancing.py	(refactored)
@@ -26,7 +26,7 @@
 def load_sizes(size,n,dim):
     sizes = np.empty((size,3),dtype=int)
     splitsize = 1.0/size*n
-    for i in xrange(size):
+    for i in range(size):
         start = int(round(i*splitsize))
         stop = int(round((i+1)*splitsize))
         sizes[i][0] = dim*(stop-start)
--- PAOFLOW/src/defs/pfaffian.py	(original)
+++ PAOFLOW/src/defs/pfaffian.py	(refactored)
@@ -18,7 +18,7 @@
 
 """A package for computing Pfaffians"""
 
-from __future__ import division
+
 import numpy as np
 import scipy.linalg as la
 import scipy.sparse as sp
@@ -123,7 +123,7 @@
     if calc_q:
         Q = np.eye(A.shape[0], dtype=A.dtype)
 
-    for i in xrange(A.shape[0]-2):
+    for i in range(A.shape[0]-2):
         #Find a Householder vector to eliminate the i-th column
         v, tau, alpha = householder(A[i+1:,i])
         A[i+1, i] = alpha
@@ -177,7 +177,7 @@
     if calc_P:
         Pv = np.arange(n)
 
-    for k in xrange(n-2):
+    for k in range(n-2):
         #First, find the largest entry in A[k+1:,k] and
         #permute it to A[k+1,k]
         kp = k+1+np.abs(A[k+1:,k]).argmax()
@@ -287,7 +287,7 @@
 
     pfaffian_val = 1.0
 
-    for k in xrange(0, n-1, 2):
+    for k in range(0, n-1, 2):
         #First, find the largest entry in A[k+1:,k] and
         #permute it to A[k+1,k]
         kp = k+1+np.abs(A[k+1:,k]).argmax()
@@ -365,7 +365,7 @@
 
     pfaffian_val = 1.
 
-    for i in xrange(A.shape[0]-2):
+    for i in range(A.shape[0]-2):
         #Find a Householder vector to eliminate the i-th column
         v, tau, alpha = householder(A[i+1:,i])
         A[i+1, i] = alpha
--- PAOFLOW/src/defs/plot_compare_PAO_DFT_eigs.py	(original)
+++ PAOFLOW/src/defs/plot_compare_PAO_DFT_eigs.py	(refactored)
@@ -23,7 +23,7 @@
 
     ispin = 0 #plots only 1 spin channel
     #for ispin in xrange(nspin):
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         if read_S:
             eigval,_ = LA.eigh(Hks[:,:,ik,ispin],Sks[:,:,ik],lower=False)
         else:
@@ -32,7 +32,7 @@
 
     fig=plt.figure
     nbnds_dft,_,_=my_eigsmat.shape
-    for i in xrange(nbnds_dft):
+    for i in range(nbnds_dft):
         #print("{0:d}".format(i))
         yy = my_eigsmat[i,:,ispin]
         if i==0:
@@ -40,7 +40,7 @@
         else:
             plt.plot(yy,'ok',markersize=3,markeredgecolor='lime',markerfacecolor='lime')
 
-    for i in xrange(nawf):
+    for i in range(nawf):
         yy = E_k[i,:,ispin]
         if i==0:
             plt.plot(yy,'ok',markersize=2,markeredgecolor='None',label='PAO')
--- PAOFLOW/src/defs/read_QE_output_xml_parse.py	(original)
+++ PAOFLOW/src/defs/read_QE_output_xml_parse.py	(refactored)
@@ -9,7 +9,7 @@
 # in the root directory of the present distribution,
 # or http://www.gnu.org/copyleft/gpl.txt .
 #
-from __future__ import print_function
+
 import numpy as np
 import xml.etree.cElementTree as ET
 import sys
@@ -78,7 +78,7 @@
                 natoms=int(float(elem.findall("NUMBER_OF_ATOMS")       [0].text.split()[0]))
 
                 tau = np.zeros((natoms,3),dtype=float)
-                for n in xrange(natoms):
+                for n in range(natoms):
                     string="ATOM."+str(n+1)
                     aux = elem.findall(string)[0].attrib['tau'].split()
                     tau[n,:]=np.array(aux,dtype="float32")
--- PAOFLOW/src/defs/read_inputfile_xml_parse.py	(original)
+++ PAOFLOW/src/defs/read_inputfile_xml_parse.py	(refactored)
@@ -10,7 +10,7 @@
 # or http://www.gnu.org/copyleft/gpl.txt .
 #
 
-from __future__ import print_function
+
 import os, sys, traceback
 import xml.etree.cElementTree as ET
 import numpy as np
--- PAOFLOW/src/defs/read_new_QE_output_xml_parse.py	(original)
+++ PAOFLOW/src/defs/read_new_QE_output_xml_parse.py	(refactored)
@@ -9,7 +9,7 @@
 # in the root directory of the present distribution,
 # or http://www.gnu.org/copyleft/gpl.txt .
 #
-from __future__ import print_function
+
 import numpy as np
 import xml.etree.cElementTree as ET
 import sys
@@ -89,7 +89,7 @@
                 # Atomic Positions
                 natoms=int(float(elem.findall("atomic_structure")[0].attrib['nat']))
                 tau = np.zeros((natoms,3),dtype=float)
-                for n in xrange(natoms):
+                for n in range(natoms):
                     aux = elem.findall("atomic_structure/atomic_positions/atom")[n].text.split()
                     tau[n,:]=np.array(aux,dtype="float32")
 			
--- PAOFLOW/src/defs/smearing.py	(original)
+++ PAOFLOW/src/defs/smearing.py	(refactored)
@@ -32,7 +32,7 @@
     nh = 5
     coeff = np.zeros(2*nh)
     coeff[0] = 1.
-    for n in xrange(2,2*nh,2):
+    for n in range(2,2*nh,2):
         m = n/2
         coeff[n] = (-1.)**m/(math.factorial(m)*4.0**m*np.sqrt(np.pi))
 
@@ -49,7 +49,7 @@
     nh = 5
     coeff = np.zeros(2*nh)
     coeff[0] = 0.
-    for n in xrange(2,2*nh,2):
+    for n in range(2,2*nh,2):
         m = n/2
         coeff[n-1] = (-1.)**m/(math.factorial(m)*4.0**m*np.sqrt(np.pi))
 
--- PAOFLOW/src/defs/write_PAO_eigs.py	(original)
+++ PAOFLOW/src/defs/write_PAO_eigs.py	(refactored)
@@ -30,7 +30,7 @@
     if evecs:
         v_k = np.zeros((nkpnts,nawf,nawf),dtype=complex)
 
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         if read_S:
             eigval,eigvec = LA.eigh(Hks[:,:,ik,ispin],Sks[:,:,ik])
         else:
@@ -43,13 +43,13 @@
         ipad = False
         if ipad:
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(nkpnts):
-                for nb in xrange(nawf):
+            for ik in range(nkpnts):
+                for nb in range(nawf):
                     f.write('%3d  %.5f \n' %(ik,E_k[ik,nb]))
             f.close()
         else:
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 s="%d\t"%ik
                 for  j in E_k[ik,:]:s += "%3.5f\t"%j
                 s+="\n"
--- PAOFLOW/src/externals/acbn0/examples/MgO/Molecule.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/Molecule.py	(refactored)
@@ -88,11 +88,11 @@
             nat = int(line.split()[0])
             title = lines.pop(0)
             atoms = []
-            for i in xrange(nat):
+            for i in range(nat):
                 line = lines.pop(0)
                 words = line.split()
                 atno = sym2no[words[0]]
-                x,y,z = map(float,words[1:])
+                x,y,z = list(map(float,words[1:]))
                 atoms.append((atno,(x,y,z)))
             atoms = Molecule("XYZ geometry #%d" % igeo,atoms)
             igeo += 1
@@ -235,12 +235,12 @@
 format_handlers= HandlerList(Handler)
 class PyQuanteStringHandler(StringHandler):
     def read(self, string, format):
-        if not format_handlers.has_key(format):
+        if format not in format_handlers:
             raise FormatUnsupported("Format %s not supported"%format)
         fh = format_handlers[format]()
         return fh.read(string)
     def write(self, data, format):
-        if not format_handlers.has_key(format):
+        if format not in format_handlers:
             raise FormatUnsupported("Format %s not supported"%format)
         fh = format_handlers[format]()
         return fh.write(data)
@@ -299,7 +299,7 @@
 
 
 sym2no = {}
-for i in xrange(len(symbol)):
+for i in range(len(symbol)):
     sym2no[symbol[i]] = i
     sym2no[symbol[i].lower()] = i
 
@@ -392,7 +392,7 @@
     def get_nel_mindo(self): return self.Z
 
     def update_coords(self,xyz): self.r = array(xyz)
-    def update_from_atuple(self,(atno,xyz)): self.update_coords(xyz)
+    def update_from_atuple(self, xxx_todo_changeme): (atno,xyz) = xxx_todo_changeme; self.update_coords(xyz)
     
     def set_force(self,fxfyfz): self.f = array(fxfyfz)
     def set_velocity(self,vxvyvz): self.vel = array(vxvyvz)
@@ -485,14 +485,14 @@
     def update_from_atuples(self,geo):
         nat = len(geo)
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_from_atuple(geo[i])
         return
 
     def update_coords(self,coords):
         nat = len(coords)/3
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_coords(coords[3*i:3*i+3])
         return
 
@@ -543,9 +543,9 @@
     def get_nel(self,charge=None):
         if charge:
             # Deprecation warning inserted 8/2005
-            print "Warning: use of get_nel(charge) has been deprecated"
-            print "Please supply charge at construction of molecule or use"
-            print "mol.set_charge(charge)"
+            print("Warning: use of get_nel(charge) has been deprecated")
+            print("Please supply charge at construction of molecule or use")
+            print("mol.set_charge(charge)")
             self.set_charge(charge)
         nel = -self.charge
         for atom in self.atoms: nel += atom.get_nel()
@@ -554,9 +554,9 @@
     def get_enuke(self):
         enuke = 0.
         nat = len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             ati = self.atoms[i]
-            for j in xrange(i):
+            for j in range(i):
                 atj = self.atoms[j]
                 enuke += ati.get_nuke_chg()*atj.get_nuke_chg()/ati.dist(atj)
         return enuke
@@ -569,20 +569,20 @@
 
         if (nel%2 == 0 and multiplicity%2 == 0) \
                or (nel%2 == 1 and multiplicity%2 == 1):
-            print "Incompatible number of electrons and spin multiplicity"
-            print "nel = ",nel
-            print "multiplicity = ",multiplicity
+            print("Incompatible number of electrons and spin multiplicity")
+            print("nel = ",nel)
+            print("multiplicity = ",multiplicity)
             raise Exception("Incompatible number of electrons and spin multiplicity")
 
         nopen = multiplicity-1
         nclosed,ierr = divmod(nel-nopen,2)
         if ierr:
-            print "Error in Molecule.get_closedopen()"
-            print 'nel = ',nel
-            print 'multiplicity = ',multiplicity
-            print 'nopen = ',nopen
-            print 'nclosed = ',nclosed
-            print 'ierr = ',ierr
+            print("Error in Molecule.get_closedopen()")
+            print('nel = ',nel)
+            print('multiplicity = ',multiplicity)
+            print('nopen = ',nopen)
+            print('nclosed = ',nclosed)
+            print('ierr = ',ierr)
             raise Exception("Error in Molecule.get_closedopen()")
         return nclosed, nopen
 
@@ -606,7 +606,7 @@
         "Transform to inertial coordinates"
 
         rcom = self.com()
-        print "Translating to COM: ",rcom
+        print("Translating to COM: ",rcom)
         self.translate(-rcom)
         I = zeros((3,3),'d')
         for atom in self:
@@ -623,10 +623,10 @@
             I[1,2] -= m*y*z
             I[2,1] = I[1,2]
         E,U = eigh(I)
-        print "Moments of inertial ",E
+        print("Moments of inertial ",E)
         self.urotate(U)
-        print "New coordinates: "
-        print self
+        print("New coordinates: ")
+        print(self)
         return
 
     def urotate(self,U):
@@ -676,7 +676,7 @@
         words = line.split()
         if not words: continue
         sym = cleansym(words[0])
-        xyz = map(float,words[1:4])
+        xyz = list(map(float,words[1:4]))
         atoms.append((sym,xyz))
     return Molecule(name,atoms,**opts)
 
@@ -708,6 +708,6 @@
     h2o = Molecule('h2o',
                    [('O',(0.,0.,0.)),('H',(1.,0.,0.)),('H',(0.,1.,0.))],
                    units='Angstrom')
-    print h2o
-    print h2o.subsystem([0,1])
-    
+    print(h2o)
+    print(h2o.subsystem([0,1]))
+    
--- PAOFLOW/src/externals/acbn0/examples/MgO/acbn0.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/acbn0.py	(refactored)
@@ -29,11 +29,11 @@
 
 try:
     from cints import contr_coulomb_v3 as ccc
-except Exception,e:
+except Exception as e:
     logging.warning('cints did not properly import. Switching to pyints.') 
     logging.warning(e)
-    print 'cints did not properly import. Switching to pyints.'
-    print e
+    print('cints did not properly import. Switching to pyints.')
+    print(e)
     from pyints import contr_coulomb_v2 as ccc
 
 
@@ -53,7 +53,7 @@
         Nlm_aux = Nlm_aux + kpnts_wght[nk]*Nlm_k[:,:,nk]
     Nlm_aux = Nlm_aux/float(np.sum(kpnts_wght))
     Nlm_0 = np.sum(Nlm_aux,axis=1)
-    print "get_Nmm_spin: Nlm_0 for spin = %s -->"%spin_label, Nlm_0.real
+    print("get_Nmm_spin: Nlm_0 for spin = %s -->"%spin_label, Nlm_0.real)
     return Nlm_0
 
 def get_hartree_energy_spin(DR_0_up,DR_0_down,bfs,reduced_basis_2e,fpath):
@@ -92,14 +92,14 @@
     for i,atomcoords in enumerate(coords):
         myatomlist.append( (atlabels[i].strip(),(atomcoords[0],atomcoords[1],atomcoords[2])) )
         
-    print myatomlist
+    print(myatomlist)
     atoms=Molecule('unitcell',atomlist = myatomlist,units = 'Angstrom')
     
     #inttol = 1e-6 # Tolerance to which integrals must be equal
     
     basis_file_path = fpath
     bfs = integs.my_getbasis(atoms,basis_file_path)
-    print "Done generating bfs"
+    print("Done generating bfs")
     return bfs
 
 def write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,spin_label,Hks,Sks):
@@ -191,13 +191,13 @@
     kpnts = np.loadtxt(fin)
     fin.close
     nkpnts  = kpnts.shape[0]
-    print "read_txt_data: number of kpoints = %d"%nkpnts
+    print("read_txt_data: number of kpoints = %d"%nkpnts)
 
     fin   = open(fpath+'/'+'kovp.txt',"r")
     kovp_0 = np.loadtxt(fin)
     fin.close
     nbasis  = int(np.sqrt(kovp_0.shape[0]/float(nkpnts)))
-    print "read_txt_data: nbasis = %s"%nbasis
+    print("read_txt_data: nbasis = %s"%nbasis)
     kovp_1  = kovp_0[:,0]+1j*kovp_0[:,1]
     kovp    = np.reshape(kovp_1,(nbasis,nbasis,nkpnts),order='F')
 
@@ -209,7 +209,7 @@
         elif ispin==0 and nspin==1 :
            fname = 'kham.txt'
         else :
-           print 'wrong case 1'
+           print('wrong case 1')
         fin    = open(fpath+'/'+fname,"r")
         kham_0 = np.loadtxt(fin)
         fin.close
@@ -222,7 +222,7 @@
         elif ispin==0 and nspin==1 :
            kham_nospin = kham
         else :
-           print 'wrong case 2'
+           print('wrong case 2')
     
     if nspin == 1: 
        f = open(fpath+'/Hk_nospin',"wb")
@@ -244,7 +244,7 @@
        f.close()
        return nkpnts,kpnts,kpnts_wght,kovp,kham_up,kham_down
     else:
-       print "wrong case 3"
+       print("wrong case 3")
 
 def get_DR_0_spin(fpath,spin_label,kpnts_wght):
     import numpy as np
@@ -255,15 +255,15 @@
     f = open(fpath +'/Dk_reduced_file_'+spin_label,"rb")
     Dk      = np.load(f);
     f.close()
-    print "get_DR_0_spin: Dk reduced spin %s found, shaped %d x %d x %d"%(spin_label,Dk.shape[0],Dk.shape[1],Dk.shape[2])
+    print("get_DR_0_spin: Dk reduced spin %s found, shaped %d x %d x %d"%(spin_label,Dk.shape[0],Dk.shape[1],Dk.shape[2]))
     
     nkpnts     =kpnts_wght.shape[0]
-    print "get_DR_0_spin: number of kpoints %d"%nkpnts
+    print("get_DR_0_spin: number of kpoints %d"%nkpnts)
 
     #Overwrite nawf, in case masking of awfc was use
     nawf = Dk.shape[0]
-    print "get_DR_0_spin: number of basis %d"%nawf
-    print "get_DR_0_spin: total kpoints weight %f"%np.sum(kpnts_wght)
+    print("get_DR_0_spin: number of basis %d"%nawf)
+    print("get_DR_0_spin: total kpoints weight %f"%np.sum(kpnts_wght))
     
     D = np.zeros((nawf,nawf),dtype=np.complex128)
     for nk in range(nkpnts):
@@ -299,7 +299,7 @@
     Bohr2Angs =  0.529177249
 
     #%%
-    print "Generate PyQuante instance of the BFS class"
+    print("Generate PyQuante instance of the BFS class")
     bfs     = read_basis_unitcell(fpath,latvects,coords,atlabels)
     nbasis  = len(bfs)
     fout.write("PyQuante: Number of basis per prim cell is %d\n"%nbasis)
@@ -312,7 +312,7 @@
     elif nspin == 2: 
        nkpnts,kpnts,kpnts_wght,Sks,Hks_up,Hks_down = read_txtdata(fpath,nspin)
     else:
-       print 'wrong case 1'
+       print('wrong case 1')
     
 
     fout.write('Calculating Nlm_k and reduced D_k''s\n')
@@ -323,7 +323,7 @@
        nocc_mo_gamma = write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,'up',Hks_up,Sks)
        nocc_mo_gamma = write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,'down',Hks_down,Sks)
     else:
-       print 'wrong case 2'
+       print('wrong case 2')
 
     fout.write('Calculating Nlm_0\n')
     print('Calculating Nlm_0')
@@ -333,7 +333,7 @@
        Nlm_0_up     = get_Nmm_spin(fpath,'up'    ,Hks_up    ,Sks,kpnts_wght)
        Nlm_0_down   = get_Nmm_spin(fpath,'down'  ,Hks_down  ,Sks,kpnts_wght)
     else:
-       print 'wrong case 3'
+       print('wrong case 3')
     
     if nspin == 1: 
        Naa=0.0
@@ -370,23 +370,23 @@
             for mp in range(lm_size):
                 Nab = Nab + Nlm_0_up[m]*Nlm_0_down[mp]
     else:
-       print 'wrong case 4'
+       print('wrong case 4')
 
     if nspin == 1: 
-       print "NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+2*Naa.real)
+       print("NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+2*Naa.real))
        denominator_U = 2*Nab.real+2*Naa.real
        denominator_J = 2*Naa.real
     elif nspin == 2: 
-       print "NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+Naa.real+Nbb.real)
+       print("NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+Naa.real+Nbb.real))
        denominator_U = 2*Nab.real+Naa.real+Nbb.real
        denominator_J = Naa.real+Nbb.real
     else:
-       print 'wrong case'
+       print('wrong case')
     fout.write("denominator_U = %f\ndenominator_J = %f\n"%(denominator_U,denominator_J))
-    print("denominator_U = %f\ndenominator_J = %f"%(denominator_U,denominator_J))
-
-
-    print "Finding the Coulomb and exchange energies"
+    print(("denominator_U = %f\ndenominator_J = %f"%(denominator_U,denominator_J)))
+
+
+    print("Finding the Coulomb and exchange energies")
     fout.write("Started finding the Coulomb and exchange energies at %s\n"%(time.ctime()))
 
     ta = time.time()
@@ -403,7 +403,7 @@
     t0   = time.time() 
     U_energy,J_energy = get_hartree_energy_spin(DR_0_up,DR_0_down,bfs,reduced_basis_2e,fpath)
     t1   = time.time() 
-    print("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s"%(U_energy,J_energy,t1-t0))
+    print(("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s"%(U_energy,J_energy,t1-t0)))
     fout.write("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s\n"%(U_energy,J_energy,t1-t0))
 
     SI = 0
@@ -411,16 +411,16 @@
     U = (U_energy -2*SI)/denominator_U
     J = (J_energy -2*SI)/denominator_J
 
-    print("Parameter U=%f eV"%(U*Ha2eV))
+    print(("Parameter U=%f eV"%(U*Ha2eV)))
     fout.write("Parameter U=%f eV\n"%(U*Ha2eV))
-    print("Parameter J=%f eV"%(J*Ha2eV))
+    print(("Parameter J=%f eV"%(J*Ha2eV)))
     fout.write("Parameter J=%f eV\n"%(J*Ha2eV))
     
     if J*Ha2eV == float('Inf'):
-        print("Parameter U_eff = %f eV"%(U*Ha2eV))
+        print(("Parameter U_eff = %f eV"%(U*Ha2eV)))
         fout.write("Parameter U_eff = %f eV\n"%(U*Ha2eV))
     else:
-        print("Parameter U_eff = %f eV"%((U-J)*Ha2eV))
+        print(("Parameter U_eff = %f eV"%((U-J)*Ha2eV)))
         fout.write("Parameter U_eff = %f eV\n"%((U-J)*Ha2eV))
 
 
--- PAOFLOW/src/externals/acbn0/examples/MgO/integs.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/integs.py	(refactored)
@@ -68,18 +68,18 @@
     import math  as m
     bfs = []
     for atom in atoms:
-        print 'Building basis for atom ', atom.atid, atom.symbol()
+        print('Building basis for atom ', atom.atid, atom.symbol())
         basis_data_file = basis_files_path+'/'+atom.symbol()+'_basis'
         if os.path.exists(basis_data_file+'.py'):
-           print '\tFile '+basis_data_file+' found'
+           print('\tFile '+basis_data_file+' found')
 	else:
-           print '\tFile '+basis_data_file+' not found. Exiting ...'
+           print('\tFile '+basis_data_file+' not found. Exiting ...')
            sys.exit()
         exec('execfile("'+basis_data_file+'.py")')
         #print basis_data
         bs = basis_data[atom.atno]
         for shell in bs:
-	    print '\t One shell (L) found'
+	    print('\t One shell (L) found')
             for subshell in shell:
                 bf = myCGBF(atom.pos(),atom.atid)
                 pgto_counter = 0
@@ -94,7 +94,7 @@
                     bf.pcoefs.append(coeff)
                     bf.pexps.append(zeta)
                     pgto_counter += 1
-                print '\t\t One subshell (M) spanned with %d PGTOs found' % pgto_counter
+                print('\t\t One subshell (M) spanned with %d PGTOs found' % pgto_counter)
                 bfs.append(bf)
     return bfs
 
@@ -103,7 +103,7 @@
     """Store integrals in a long array in the form (ij|kl) (chemists
     notation. We only need i>=j, k>=l, and ij <= kl"""
     from array import array
-    print 'Calculationg 2e integrals using %s'%coul_func.__name__
+    print('Calculationg 2e integrals using %s'%coul_func.__name__)
     nbf = len(bfs)
     totlen = nbf*(nbf+1)*(nbf*nbf+nbf+2)/8
     Ints = array('d',[0]*totlen)
@@ -145,10 +145,10 @@
            dl.append(x[0]) 
            dm.append(x[1]) 
            dn.append(x[2]) 
-       al=map(float,al);am=map(float,am);an=map(float,an)
-       bl=map(float,bl);bm=map(float,bm);bn=map(float,bn)
-       cl=map(float,cl);cm=map(float,cm);cn=map(float,cn)
-       dl=map(float,dl);dm=map(float,dm);dn=map(float,dn)
+       al=list(map(float,al));am=list(map(float,am));an=list(map(float,an))
+       bl=list(map(float,bl));bm=list(map(float,bm));bn=list(map(float,bn))
+       cl=list(map(float,cl));cm=list(map(float,cm));cn=list(map(float,cn))
+       dl=list(map(float,dl));dm=list(map(float,dm));dn=list(map(float,dn))
 
        Jij = coul_func(a.pexps,a.pcoefs,a.pnorms,a.origin,al,am,an,
                        b.pexps,b.pcoefs,b.pnorms,b.origin,bl,bm,bn,
@@ -181,11 +181,11 @@
     t0 = time()
     int0 = get2ints(bfs,pycc)
     t1 = time()
-    print "time:    ",t1-t0, ' s'
-    print 'Calculationg 2e integrals'
+    print("time:    ",t1-t0, ' s')
+    print('Calculationg 2e integrals')
     mesg= """Store integrals in a long array in the form (ij|kl) (chemists
     notation. We only need i>=j, k>=l, and ij <= kl"""
-    print mesg
+    print(mesg)
     from array import array
     nbf = len(bfs)
     totlen = nbf*(nbf+1)*(nbf*nbf+nbf+2)/8
@@ -199,7 +199,7 @@
                     if ij >= kl:
                         intval = int0[ijkl2intindex(i,j,k,l)]
                         if intval >= 1E-6:
-                         print 'I= %d  J= %d  K= %d  L= %d  Int= %f' %(i+1,j+1,k+1,l+1,intval)
+                         print('I= %d  J= %d  K= %d  L= %d  Int= %f' %(i+1,j+1,k+1,l+1,intval))
     return int0,bfs
 
 #if __name__ == '__main__': test()
--- PAOFLOW/src/externals/acbn0/examples/MgO/pyints.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/pyints.py	(refactored)
@@ -17,10 +17,10 @@
                      dexps,dcoefs,dnorms,xyzd,powd):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],powa[i],aexps[i],
                                              xyzb,bnorms[j],powb[j],bexps[j],
                                              xyzc,cnorms[k],powc[k],cexps[k],
@@ -35,10 +35,10 @@
                      dexps,dcoefs,dnorms,xyzd,powdx,powdy,powdz):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],(powax[i],poway[i],powaz[i]),aexps[i],
                                              xyzb,bnorms[j],(powax[j],poway[j],powaz[j]),bexps[j],
                                              xyzc,cnorms[k],(powax[k],poway[k],powaz[k]),cexps[k],
@@ -49,11 +49,16 @@
 ##################################################################################################
 
 
-def coulomb_repulsion((xa,ya,za),norma,(la,ma,na),alphaa,
-                      (xb,yb,zb),normb,(lb,mb,nb),alphab,
-                      (xc,yc,zc),normc,(lc,mc,nc),alphac,
-                      (xd,yd,zd),normd,(ld,md,nd),alphad):
-
+def coulomb_repulsion(xxx_todo_changeme,norma, xxx_todo_changeme1,alphaa, xxx_todo_changeme2,normb, xxx_todo_changeme3,alphab, xxx_todo_changeme4,normc, xxx_todo_changeme5,alphac, xxx_todo_changeme6,normd, xxx_todo_changeme7,alphad):
+
+    (xa,ya,za) = xxx_todo_changeme
+    (la,ma,na) = xxx_todo_changeme1
+    (xb,yb,zb) = xxx_todo_changeme2
+    (lb,mb,nb) = xxx_todo_changeme3
+    (xc,yc,zc) = xxx_todo_changeme4
+    (lc,mc,nc) = xxx_todo_changeme5
+    (xd,yd,zd) = xxx_todo_changeme6
+    (ld,md,nd) = xxx_todo_changeme7
     rab2 = dist2((xa,ya,za),(xb,yb,zb)) #needs dist2
     rcd2 = dist2((xc,yc,zc),(xd,yd,zd)) #needs dist2
     xp,yp,zp = gaussian_product_center(alphaa,(xa,ya,za),alphab,(xb,yb,zb)) #needs gaussian_product_center
@@ -68,9 +73,9 @@
     Bz = B_array(na,nb,nc,nd,zp,za,zb,zq,zc,zd,gamma1,gamma2,delta) #needs B_array
 
     sum = 0.
-    for I in xrange(la+lb+lc+ld+1):
-        for J in xrange(ma+mb+mc+md+1):
-            for K in xrange(na+nb+nc+nd+1):
+    for I in range(la+lb+lc+ld+1):
+        for J in range(ma+mb+mc+md+1):
+            for K in range(na+nb+nc+nd+1):
                 sum = sum + Bx[I]*By[J]*Bz[K]*Fgamma(I+J+K,0.25*rpq2/delta) #needs Fgamma
 
     return 2*pow(pi,2.5)/(gamma1*gamma2*sqrt(gamma1+gamma2)) \
@@ -84,11 +89,11 @@
 def B_array(l1,l2,l3,l4,p,a,b,q,c,d,g1,g2,delta):
     Imax = l1+l2+l3+l4+1
     B = [0]*Imax
-    for i1 in xrange(l1+l2+1):
-        for i2 in xrange(l3+l4+1):
-            for r1 in xrange(i1/2+1):
-                for r2 in xrange(i2/2+1):
-                    for u in xrange((i1+i2)/2-r1-r2+1):
+    for i1 in range(l1+l2+1):
+        for i2 in range(l3+l4+1):
+            for r1 in range(i1/2+1):
+                for r2 in range(i2/2+1):
+                    for u in range((i1+i2)/2-r1-r2+1):
                         I = i1+i2-2*(r1+r2)-u
                         B[I] = B[I] + B_term(i1,i2,r1,r2,u,l1,l2,l3,l4, 
                                              p,a,b,q,c,d,g1,g2,delta)   #needs B_term
@@ -108,7 +113,7 @@
 def binomial_prefactor(s,ia,ib,xpa,xpb):
     "From Augspurger and Dykstra"
     sum = 0
-    for t in xrange(s+1):
+    for t in range(s+1):
         if s-ia <= t <= ib:
                 sum = sum + binomial(ia,s-t)*binomial(ib,t)* \
                   pow(xpa,ia-s+t)*pow(xpb,ib-t)
@@ -186,13 +191,13 @@
 
     ap = a
     delt = sum = 1./a
-    for i in xrange(ITMAX):
+    for i in range(ITMAX):
         ap=ap+1.
         delt=delt*x/ap
         sum=sum+delt
         if abs(delt) < abs(sum)*EPS: break
     else:
-        print 'a too large, ITMAX too small in gser'
+        print('a too large, ITMAX too small in gser')
     gamser=sum*exp(-x+a*log(x)-gln)
     return gamser,gln
 
@@ -207,7 +212,7 @@
     c=1./FPMIN
     d=1./b
     h=d
-    for i in xrange(1,ITMAX+1):
+    for i in range(1,ITMAX+1):
         an=-i*(i-a)
         b=b+2.
         d=an*d+b
@@ -219,7 +224,7 @@
         h=h*delt
         if abs(delt-1.) < EPS: break
     else:
-        print 'a too large, ITMAX too small in gcf'
+        print('a too large, ITMAX too small in gcf')
     gammcf=exp(-x+a*log(x)-gln)*h
     return gammcf,gln
 
@@ -234,7 +239,7 @@
     tmp=x+5.5
     tmp = tmp - (x+0.5)*log(tmp)
     ser=1.000000000190015 # don't you just love these numbers?!
-    for j in xrange(6):
+    for j in range(6):
         y = y+1
         ser = ser+cof[j]/y
     return -tmp+log(2.5066282746310005*ser/x);
--- PAOFLOW/src/externals/acbn0/examples/MgO/scfuj.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/scfuj.py	(refactored)
@@ -133,7 +133,7 @@
                                 return float(alat[0]),paramMatrix
 
                         else:
-                                print 'No card!'
+                                print('No card!')
                                 return float(alat[0]),[[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]]
 
 
@@ -159,7 +159,7 @@
                 atmPosRegex1 = re.compile(r".*=.*\((.*)\)\n+",re.MULTILINE)
                 atmPos = atmPosRegex1.findall(lines1)
                 atmPosList = []
-                for i in atmPos:atmPosList.append(map(float,i.split()))
+                for i in atmPos:atmPosList.append(list(map(float,i.split())))
 
 				#Convert fractional atomic coordinates to cartesian coordinates using the lattice vectors
                 atmPosStr = ""
@@ -195,19 +195,19 @@
                 #For each atomic species
                 for atmSp in atmSpList:
 
-                        print "Creating acbn0 inpufile for %s"%atmSp
+                        print("Creating acbn0 inpufile for %s"%atmSp)
 
                         #Get orbital type to apply Hubbard correction
                         ql = get_orbital(atmSp.strip('0123456789'))
 
                         #Get list of all orbitals of type ql of the same species
                         eqOrbRegex = re.compile(r"state #\s*(\d*): atom.*\(%s.*\).*\(l=%d.*\)\n"%(atmSp.strip('0123456789'),ql),re.MULTILINE)
-                        eqOrbList = map(int, map(float,eqOrbRegex.findall(proj_lines)))
+                        eqOrbList = list(map(int, list(map(float,eqOrbRegex.findall(proj_lines)))))
                         red_basis = [x - 1 for x in eqOrbList]
 
                         #Get ones relevant for hubbard center
                         eqOrbRegex = re.compile(r"state #\s*(\d*): atom.*\(%s\s*\).*\(l=%d.*\)\n"%(atmSp,ql),re.MULTILINE)
-                        eqOrbList = map(int, map(float,eqOrbRegex.findall(proj_lines)));print eqOrbList
+                        eqOrbList = list(map(int, list(map(float,eqOrbRegex.findall(proj_lines)))));print(eqOrbList)
                         red_basis_for2e = [x - 1 for x in eqOrbList]
                         #Get list of orbitals of type l for one atom of the species
                         red_basis_2e = []
@@ -249,11 +249,11 @@
                         cmd="python %s/acbn0.py %s > /dev/null"%(subdir1,os.path.join(subdir,infnm))
 
 			try:
-                        	print "Starting python acbn0.py %s\n"%(os.path.join(subdir,infnm))
+                        	print("Starting python acbn0.py %s\n"%(os.path.join(subdir,infnm)))
 				subprocess.check_output([cmd],shell=True)
-	                        print "Finished python acbn0.py %s\n"%(os.path.join(subdir,infnm))
+	                        print("Finished python acbn0.py %s\n"%(os.path.join(subdir,infnm)))
 			except subprocess.CalledProcessError as e:
-				print "######### ABORTING ACBN0 LOOP ######### \n FAILED %s \n %s\n"%(cmd,e)
+				print("######### ABORTING ACBN0 LOOP ######### \n FAILED %s \n %s\n"%(cmd,e))
 				raise SystemExit
 
         acbn0_inFileList = gen_input(prefix,nspin)
@@ -281,12 +281,12 @@
 	                        acbn0_Uval = re.findall("U_eff\s*=\s*(\d+.\d+)",lines)[0]
 	                        Uvals[isp] = float(acbn0_Uval)
 			except Exception as e:
-				print "######### ABORTING ACBN0 LOOP ######### \n Could not find U values from acbn0 output"
+				print("######### ABORTING ACBN0 LOOP ######### \n Could not find U values from acbn0 output")
 				raise SystemExit
                 else:
                         Uvals[isp] = 0.001
 
-	print Uvals
+	print(Uvals)
 
 	#Record U values in a Log file
         if os.path.isfile(os.path.join(subdir,'%s_uValLog.log' % prefix)):
@@ -311,7 +311,7 @@
 	inputfile = fin.read()
 	fin.close()
 
-	print "Updating U values of %s with "%infile, Uvals
+	print("Updating U values of %s with "%infile, Uvals)
 		
         #Get species
         species = re.findall("(\w+).*UPF",inputfile)
@@ -347,7 +347,7 @@
 		try:
 			nspin = int(regEx.findall(scfInput)[0])
 		except Exception as e:
-			print "Detected Non-spin polarized calculation"
+			print("Detected Non-spin polarized calculation")
 			nspin = 1
 			pass
 
@@ -382,7 +382,7 @@
 		elif nspin == 2:
 			calcList = ['scf','nscf','pdos','PAO_bands_up','PAO_bands_down','acbn0']
 
-		print "List of calculations for each ACBN0 iteration ", str(calcList).strip('[]')
+		print("List of calculations for each ACBN0 iteration ", str(calcList).strip('[]'))
 
 		engine = {'scf':'espresso',
 			  'nscf':'espresso',
@@ -410,12 +410,12 @@
 				#	if calc == 'nscf':
 				#		os.system("cp -r %s %s"%(initDir, bakDir))
 							
-					print "Starting %s in %s"%(command, subdir)
+					print("Starting %s in %s"%(command, subdir))
 					subprocess.check_output([command],shell=True)
-					print "Finished %s in %s"%(command, subdir)
+					print("Finished %s in %s"%(command, subdir))
 
 				except subprocess.CalledProcessError as e:
-					print "######### ERROR IN ACBN0 LOOP CALCULATION ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+					print("######### ERROR IN ACBN0 LOOP CALCULATION ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
 				#	pass
 					raise SystemExit
 				if "PAO" in calc:
@@ -423,10 +423,10 @@
 						PAOOutput = file("%s_%s.out"%(prefix,calc),'r').read()
 						errorList = re.findall(r'.*error #\s*\d+.*\n.*\n',PAOOutput)
 						if len(errorList) > 0:
-							print "######### ABORTING ACBN0 LOOP ######### \n FAILED %s in %s\n PAO ERROR: \n%s"%(command, subdir,errorList[0])
+							print("######### ABORTING ACBN0 LOOP ######### \n FAILED %s in %s\n PAO ERROR: \n%s"%(command, subdir,errorList[0]))
 							raise SystemExit
 					except Exception as e:
-						print e 
+						print(e) 
 						pass
 
 
@@ -470,7 +470,7 @@
 			newUvals = oneRun(prefix,scfOne=False)
 		
 			#Check for convergence
-			for key in uVals.keys():
+			for key in list(uVals.keys()):
 				if abs(uVals[key]-newUvals[key]) > uThresh:
 					convergence = False
 					break;
@@ -492,7 +492,7 @@
 			newUvals = oneRun(prefix,scfOne=False)
 		
 			#Check for convergence
-			for key in uVals.keys():
+			for key in list(uVals.keys()):
 				if abs(uVals[key]-newUvals[key]) > uThresh:
 					convergence = False
 					break;
@@ -501,7 +501,7 @@
 
 
 	else:
-		print "Usage: $PATH/scfuj.py prefix"
+		print("Usage: $PATH/scfuj.py prefix")
 
 		
 
--- PAOFLOW/src/externals/acbn0/src/Molecule.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/Molecule.py	(refactored)
@@ -88,11 +88,11 @@
             nat = int(line.split()[0])
             title = lines.pop(0)
             atoms = []
-            for i in xrange(nat):
+            for i in range(nat):
                 line = lines.pop(0)
                 words = line.split()
                 atno = sym2no[words[0]]
-                x,y,z = map(float,words[1:])
+                x,y,z = list(map(float,words[1:]))
                 atoms.append((atno,(x,y,z)))
             atoms = Molecule("XYZ geometry #%d" % igeo,atoms)
             igeo += 1
@@ -235,12 +235,12 @@
 format_handlers= HandlerList(Handler)
 class PyQuanteStringHandler(StringHandler):
     def read(self, string, format):
-        if not format_handlers.has_key(format):
+        if format not in format_handlers:
             raise FormatUnsupported("Format %s not supported"%format)
         fh = format_handlers[format]()
         return fh.read(string)
     def write(self, data, format):
-        if not format_handlers.has_key(format):
+        if format not in format_handlers:
             raise FormatUnsupported("Format %s not supported"%format)
         fh = format_handlers[format]()
         return fh.write(data)
@@ -299,7 +299,7 @@
 
 
 sym2no = {}
-for i in xrange(len(symbol)):
+for i in range(len(symbol)):
     sym2no[symbol[i]] = i
     sym2no[symbol[i].lower()] = i
 
@@ -392,7 +392,7 @@
     def get_nel_mindo(self): return self.Z
 
     def update_coords(self,xyz): self.r = array(xyz)
-    def update_from_atuple(self,(atno,xyz)): self.update_coords(xyz)
+    def update_from_atuple(self, xxx_todo_changeme): (atno,xyz) = xxx_todo_changeme; self.update_coords(xyz)
     
     def set_force(self,fxfyfz): self.f = array(fxfyfz)
     def set_velocity(self,vxvyvz): self.vel = array(vxvyvz)
@@ -485,14 +485,14 @@
     def update_from_atuples(self,geo):
         nat = len(geo)
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_from_atuple(geo[i])
         return
 
     def update_coords(self,coords):
         nat = len(coords)/3
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_coords(coords[3*i:3*i+3])
         return
 
@@ -543,9 +543,9 @@
     def get_nel(self,charge=None):
         if charge:
             # Deprecation warning inserted 8/2005
-            print "Warning: use of get_nel(charge) has been deprecated"
-            print "Please supply charge at construction of molecule or use"
-            print "mol.set_charge(charge)"
+            print("Warning: use of get_nel(charge) has been deprecated")
+            print("Please supply charge at construction of molecule or use")
+            print("mol.set_charge(charge)")
             self.set_charge(charge)
         nel = -self.charge
         for atom in self.atoms: nel += atom.get_nel()
@@ -554,9 +554,9 @@
     def get_enuke(self):
         enuke = 0.
         nat = len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             ati = self.atoms[i]
-            for j in xrange(i):
+            for j in range(i):
                 atj = self.atoms[j]
                 enuke += ati.get_nuke_chg()*atj.get_nuke_chg()/ati.dist(atj)
         return enuke
@@ -569,20 +569,20 @@
 
         if (nel%2 == 0 and multiplicity%2 == 0) \
                or (nel%2 == 1 and multiplicity%2 == 1):
-            print "Incompatible number of electrons and spin multiplicity"
-            print "nel = ",nel
-            print "multiplicity = ",multiplicity
+            print("Incompatible number of electrons and spin multiplicity")
+            print("nel = ",nel)
+            print("multiplicity = ",multiplicity)
             raise Exception("Incompatible number of electrons and spin multiplicity")
 
         nopen = multiplicity-1
         nclosed,ierr = divmod(nel-nopen,2)
         if ierr:
-            print "Error in Molecule.get_closedopen()"
-            print 'nel = ',nel
-            print 'multiplicity = ',multiplicity
-            print 'nopen = ',nopen
-            print 'nclosed = ',nclosed
-            print 'ierr = ',ierr
+            print("Error in Molecule.get_closedopen()")
+            print('nel = ',nel)
+            print('multiplicity = ',multiplicity)
+            print('nopen = ',nopen)
+            print('nclosed = ',nclosed)
+            print('ierr = ',ierr)
             raise Exception("Error in Molecule.get_closedopen()")
         return nclosed, nopen
 
@@ -606,7 +606,7 @@
         "Transform to inertial coordinates"
 
         rcom = self.com()
-        print "Translating to COM: ",rcom
+        print("Translating to COM: ",rcom)
         self.translate(-rcom)
         I = zeros((3,3),'d')
         for atom in self:
@@ -623,10 +623,10 @@
             I[1,2] -= m*y*z
             I[2,1] = I[1,2]
         E,U = eigh(I)
-        print "Moments of inertial ",E
+        print("Moments of inertial ",E)
         self.urotate(U)
-        print "New coordinates: "
-        print self
+        print("New coordinates: ")
+        print(self)
         return
 
     def urotate(self,U):
@@ -676,7 +676,7 @@
         words = line.split()
         if not words: continue
         sym = cleansym(words[0])
-        xyz = map(float,words[1:4])
+        xyz = list(map(float,words[1:4]))
         atoms.append((sym,xyz))
     return Molecule(name,atoms,**opts)
 
@@ -708,6 +708,6 @@
     h2o = Molecule('h2o',
                    [('O',(0.,0.,0.)),('H',(1.,0.,0.)),('H',(0.,1.,0.))],
                    units='Angstrom')
-    print h2o
-    print h2o.subsystem([0,1])
-    
+    print(h2o)
+    print(h2o.subsystem([0,1]))
+    
--- PAOFLOW/src/externals/acbn0/src/acbn0.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/acbn0.py	(refactored)
@@ -29,11 +29,11 @@
 
 try:
     from cints import contr_coulomb_v3 as ccc
-except Exception,e:
+except Exception as e:
     logging.warning('cints did not properly import. Switching to pyints.') 
     logging.warning(e)
-    print 'cints did not properly import. Switching to pyints.'
-    print e
+    print('cints did not properly import. Switching to pyints.')
+    print(e)
     from pyints import contr_coulomb_v2 as ccc
 
 
@@ -53,7 +53,7 @@
         Nlm_aux = Nlm_aux + kpnts_wght[nk]*Nlm_k[:,:,nk]
     Nlm_aux = Nlm_aux/float(np.sum(kpnts_wght))
     Nlm_0 = np.sum(Nlm_aux,axis=1)
-    print "get_Nmm_spin: Nlm_0 for spin = %s -->"%spin_label, Nlm_0.real
+    print("get_Nmm_spin: Nlm_0 for spin = %s -->"%spin_label, Nlm_0.real)
     return Nlm_0
 
 def get_hartree_energy_spin(DR_0_up,DR_0_down,bfs,reduced_basis_2e,fpath):
@@ -92,14 +92,14 @@
     for i,atomcoords in enumerate(coords):
         myatomlist.append( (atlabels[i].strip(),(atomcoords[0],atomcoords[1],atomcoords[2])) )
         
-    print myatomlist
+    print(myatomlist)
     atoms=Molecule('unitcell',atomlist = myatomlist,units = 'Angstrom')
     
     #inttol = 1e-6 # Tolerance to which integrals must be equal
     
     basis_file_path = fpath
     bfs = integs.my_getbasis(atoms,basis_file_path)
-    print "Done generating bfs"
+    print("Done generating bfs")
     return bfs
 
 def write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,spin_label,Hks,Sks):
@@ -191,13 +191,13 @@
     kpnts = np.loadtxt(fin)
     fin.close
     nkpnts  = kpnts.shape[0]
-    print "read_txt_data: number of kpoints = %d"%nkpnts
+    print("read_txt_data: number of kpoints = %d"%nkpnts)
 
     fin   = open(fpath+'/'+'kovp.txt',"r")
     kovp_0 = np.loadtxt(fin)
     fin.close
     nbasis  = int(np.sqrt(kovp_0.shape[0]/float(nkpnts)))
-    print "read_txt_data: nbasis = %s"%nbasis
+    print("read_txt_data: nbasis = %s"%nbasis)
     kovp_1  = kovp_0[:,0]+1j*kovp_0[:,1]
     kovp    = np.reshape(kovp_1,(nbasis,nbasis,nkpnts),order='F')
 
@@ -209,7 +209,7 @@
         elif ispin==0 and nspin==1 :
            fname = 'kham.txt'
         else :
-           print 'wrong case 1'
+           print('wrong case 1')
         fin    = open(fpath+'/'+fname,"r")
         kham_0 = np.loadtxt(fin)
         fin.close
@@ -222,7 +222,7 @@
         elif ispin==0 and nspin==1 :
            kham_nospin = kham
         else :
-           print 'wrong case 2'
+           print('wrong case 2')
     
     if nspin == 1: 
        f = open(fpath+'/Hk_nospin',"wb")
@@ -244,7 +244,7 @@
        f.close()
        return nkpnts,kpnts,kpnts_wght,kovp,kham_up,kham_down
     else:
-       print "wrong case 3"
+       print("wrong case 3")
 
 def get_DR_0_spin(fpath,spin_label,kpnts_wght):
     import numpy as np
@@ -255,15 +255,15 @@
     f = open(fpath +'/Dk_reduced_file_'+spin_label,"rb")
     Dk      = np.load(f);
     f.close()
-    print "get_DR_0_spin: Dk reduced spin %s found, shaped %d x %d x %d"%(spin_label,Dk.shape[0],Dk.shape[1],Dk.shape[2])
+    print("get_DR_0_spin: Dk reduced spin %s found, shaped %d x %d x %d"%(spin_label,Dk.shape[0],Dk.shape[1],Dk.shape[2]))
     
     nkpnts     =kpnts_wght.shape[0]
-    print "get_DR_0_spin: number of kpoints %d"%nkpnts
+    print("get_DR_0_spin: number of kpoints %d"%nkpnts)
 
     #Overwrite nawf, in case masking of awfc was use
     nawf = Dk.shape[0]
-    print "get_DR_0_spin: number of basis %d"%nawf
-    print "get_DR_0_spin: total kpoints weight %f"%np.sum(kpnts_wght)
+    print("get_DR_0_spin: number of basis %d"%nawf)
+    print("get_DR_0_spin: total kpoints weight %f"%np.sum(kpnts_wght))
     
     D = np.zeros((nawf,nawf),dtype=np.complex128)
     for nk in range(nkpnts):
@@ -299,7 +299,7 @@
     Bohr2Angs =  0.529177249
 
     #%%
-    print "Generate PyQuante instance of the BFS class"
+    print("Generate PyQuante instance of the BFS class")
     bfs     = read_basis_unitcell(fpath,latvects,coords,atlabels)
     nbasis  = len(bfs)
     fout.write("PyQuante: Number of basis per prim cell is %d\n"%nbasis)
@@ -312,7 +312,7 @@
     elif nspin == 2: 
        nkpnts,kpnts,kpnts_wght,Sks,Hks_up,Hks_down = read_txtdata(fpath,nspin)
     else:
-       print 'wrong case 1'
+       print('wrong case 1')
     
 
     fout.write('Calculating Nlm_k and reduced D_k''s\n')
@@ -323,7 +323,7 @@
        nocc_mo_gamma = write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,'up',Hks_up,Sks)
        nocc_mo_gamma = write_reduced_Dk_spin_v2(fpath,reduced_basis_dm,reduced_basis_2e,'down',Hks_down,Sks)
     else:
-       print 'wrong case 2'
+       print('wrong case 2')
 
     fout.write('Calculating Nlm_0\n')
     print('Calculating Nlm_0')
@@ -333,7 +333,7 @@
        Nlm_0_up     = get_Nmm_spin(fpath,'up'    ,Hks_up    ,Sks,kpnts_wght)
        Nlm_0_down   = get_Nmm_spin(fpath,'down'  ,Hks_down  ,Sks,kpnts_wght)
     else:
-       print 'wrong case 3'
+       print('wrong case 3')
     
     if nspin == 1: 
        Naa=0.0
@@ -370,23 +370,23 @@
             for mp in range(lm_size):
                 Nab = Nab + Nlm_0_up[m]*Nlm_0_down[mp]
     else:
-       print 'wrong case 4'
+       print('wrong case 4')
 
     if nspin == 1: 
-       print "NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+2*Naa.real)
+       print("NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+2*Naa.real))
        denominator_U = 2*Nab.real+2*Naa.real
        denominator_J = 2*Naa.real
     elif nspin == 2: 
-       print "NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+Naa.real+Nbb.real)
+       print("NaNa + NaNb + NbNa + Nbb = %f"%(2*Nab.real+Naa.real+Nbb.real))
        denominator_U = 2*Nab.real+Naa.real+Nbb.real
        denominator_J = Naa.real+Nbb.real
     else:
-       print 'wrong case'
+       print('wrong case')
     fout.write("denominator_U = %f\ndenominator_J = %f\n"%(denominator_U,denominator_J))
-    print("denominator_U = %f\ndenominator_J = %f"%(denominator_U,denominator_J))
-
-
-    print "Finding the Coulomb and exchange energies"
+    print(("denominator_U = %f\ndenominator_J = %f"%(denominator_U,denominator_J)))
+
+
+    print("Finding the Coulomb and exchange energies")
     fout.write("Started finding the Coulomb and exchange energies at %s\n"%(time.ctime()))
 
     ta = time.time()
@@ -403,7 +403,7 @@
     t0   = time.time() 
     U_energy,J_energy = get_hartree_energy_spin(DR_0_up,DR_0_down,bfs,reduced_basis_2e,fpath)
     t1   = time.time() 
-    print("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s"%(U_energy,J_energy,t1-t0))
+    print(("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s"%(U_energy,J_energy,t1-t0)))
     fout.write("Energy Uaa=%+14.10f Ha; Energy Jaa=%+14.10f Ha; %7.3f s\n"%(U_energy,J_energy,t1-t0))
 
     SI = 0
@@ -411,16 +411,16 @@
     U = (U_energy -2*SI)/denominator_U
     J = (J_energy -2*SI)/denominator_J
 
-    print("Parameter U=%f eV"%(U*Ha2eV))
+    print(("Parameter U=%f eV"%(U*Ha2eV)))
     fout.write("Parameter U=%f eV\n"%(U*Ha2eV))
-    print("Parameter J=%f eV"%(J*Ha2eV))
+    print(("Parameter J=%f eV"%(J*Ha2eV)))
     fout.write("Parameter J=%f eV\n"%(J*Ha2eV))
     
     if J*Ha2eV == float('Inf'):
-        print("Parameter U_eff = %f eV"%(U*Ha2eV))
+        print(("Parameter U_eff = %f eV"%(U*Ha2eV)))
         fout.write("Parameter U_eff = %f eV\n"%(U*Ha2eV))
     else:
-        print("Parameter U_eff = %f eV"%((U-J)*Ha2eV))
+        print(("Parameter U_eff = %f eV"%((U-J)*Ha2eV)))
         fout.write("Parameter U_eff = %f eV\n"%((U-J)*Ha2eV))
 
 
--- PAOFLOW/src/externals/acbn0/src/integs.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/integs.py	(refactored)
@@ -68,18 +68,18 @@
     import math  as m
     bfs = []
     for atom in atoms:
-        print 'Building basis for atom ', atom.atid, atom.symbol()
+        print('Building basis for atom ', atom.atid, atom.symbol())
         basis_data_file = basis_files_path+'/'+atom.symbol()+'_basis'
         if os.path.exists(basis_data_file+'.py'):
-           print '\tFile '+basis_data_file+' found'
+           print('\tFile '+basis_data_file+' found')
 	else:
-           print '\tFile '+basis_data_file+' not found. Exiting ...'
+           print('\tFile '+basis_data_file+' not found. Exiting ...')
            sys.exit()
         exec('execfile("'+basis_data_file+'.py")')
         #print basis_data
         bs = basis_data[atom.atno]
         for shell in bs:
-	    print '\t One shell (L) found'
+	    print('\t One shell (L) found')
             for subshell in shell:
                 bf = myCGBF(atom.pos(),atom.atid)
                 pgto_counter = 0
@@ -94,7 +94,7 @@
                     bf.pcoefs.append(coeff)
                     bf.pexps.append(zeta)
                     pgto_counter += 1
-                print '\t\t One subshell (M) spanned with %d PGTOs found' % pgto_counter
+                print('\t\t One subshell (M) spanned with %d PGTOs found' % pgto_counter)
                 bfs.append(bf)
     return bfs
 
@@ -103,7 +103,7 @@
     """Store integrals in a long array in the form (ij|kl) (chemists
     notation. We only need i>=j, k>=l, and ij <= kl"""
     from array import array
-    print 'Calculationg 2e integrals using %s'%coul_func.__name__
+    print('Calculationg 2e integrals using %s'%coul_func.__name__)
     nbf = len(bfs)
     totlen = nbf*(nbf+1)*(nbf*nbf+nbf+2)/8
     Ints = array('d',[0]*totlen)
@@ -145,10 +145,10 @@
            dl.append(x[0]) 
            dm.append(x[1]) 
            dn.append(x[2]) 
-       al=map(float,al);am=map(float,am);an=map(float,an)
-       bl=map(float,bl);bm=map(float,bm);bn=map(float,bn)
-       cl=map(float,cl);cm=map(float,cm);cn=map(float,cn)
-       dl=map(float,dl);dm=map(float,dm);dn=map(float,dn)
+       al=list(map(float,al));am=list(map(float,am));an=list(map(float,an))
+       bl=list(map(float,bl));bm=list(map(float,bm));bn=list(map(float,bn))
+       cl=list(map(float,cl));cm=list(map(float,cm));cn=list(map(float,cn))
+       dl=list(map(float,dl));dm=list(map(float,dm));dn=list(map(float,dn))
 
        Jij = coul_func(a.pexps,a.pcoefs,a.pnorms,a.origin,al,am,an,
                        b.pexps,b.pcoefs,b.pnorms,b.origin,bl,bm,bn,
@@ -181,11 +181,11 @@
     t0 = time()
     int0 = get2ints(bfs,pycc)
     t1 = time()
-    print "time:    ",t1-t0, ' s'
-    print 'Calculationg 2e integrals'
+    print("time:    ",t1-t0, ' s')
+    print('Calculationg 2e integrals')
     mesg= """Store integrals in a long array in the form (ij|kl) (chemists
     notation. We only need i>=j, k>=l, and ij <= kl"""
-    print mesg
+    print(mesg)
     from array import array
     nbf = len(bfs)
     totlen = nbf*(nbf+1)*(nbf*nbf+nbf+2)/8
@@ -199,7 +199,7 @@
                     if ij >= kl:
                         intval = int0[ijkl2intindex(i,j,k,l)]
                         if intval >= 1E-6:
-                         print 'I= %d  J= %d  K= %d  L= %d  Int= %f' %(i+1,j+1,k+1,l+1,intval)
+                         print('I= %d  J= %d  K= %d  L= %d  Int= %f' %(i+1,j+1,k+1,l+1,intval))
     return int0,bfs
 
 #if __name__ == '__main__': test()
--- PAOFLOW/src/externals/acbn0/src/pyints.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/pyints.py	(refactored)
@@ -17,10 +17,10 @@
                      dexps,dcoefs,dnorms,xyzd,powd):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],powa[i],aexps[i],
                                              xyzb,bnorms[j],powb[j],bexps[j],
                                              xyzc,cnorms[k],powc[k],cexps[k],
@@ -35,10 +35,10 @@
                      dexps,dcoefs,dnorms,xyzd,powdx,powdy,powdz):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],(powax[i],poway[i],powaz[i]),aexps[i],
                                              xyzb,bnorms[j],(powax[j],poway[j],powaz[j]),bexps[j],
                                              xyzc,cnorms[k],(powax[k],poway[k],powaz[k]),cexps[k],
@@ -49,11 +49,16 @@
 ##################################################################################################
 
 
-def coulomb_repulsion((xa,ya,za),norma,(la,ma,na),alphaa,
-                      (xb,yb,zb),normb,(lb,mb,nb),alphab,
-                      (xc,yc,zc),normc,(lc,mc,nc),alphac,
-                      (xd,yd,zd),normd,(ld,md,nd),alphad):
-
+def coulomb_repulsion(xxx_todo_changeme,norma, xxx_todo_changeme1,alphaa, xxx_todo_changeme2,normb, xxx_todo_changeme3,alphab, xxx_todo_changeme4,normc, xxx_todo_changeme5,alphac, xxx_todo_changeme6,normd, xxx_todo_changeme7,alphad):
+
+    (xa,ya,za) = xxx_todo_changeme
+    (la,ma,na) = xxx_todo_changeme1
+    (xb,yb,zb) = xxx_todo_changeme2
+    (lb,mb,nb) = xxx_todo_changeme3
+    (xc,yc,zc) = xxx_todo_changeme4
+    (lc,mc,nc) = xxx_todo_changeme5
+    (xd,yd,zd) = xxx_todo_changeme6
+    (ld,md,nd) = xxx_todo_changeme7
     rab2 = dist2((xa,ya,za),(xb,yb,zb)) #needs dist2
     rcd2 = dist2((xc,yc,zc),(xd,yd,zd)) #needs dist2
     xp,yp,zp = gaussian_product_center(alphaa,(xa,ya,za),alphab,(xb,yb,zb)) #needs gaussian_product_center
@@ -68,9 +73,9 @@
     Bz = B_array(na,nb,nc,nd,zp,za,zb,zq,zc,zd,gamma1,gamma2,delta) #needs B_array
 
     sum = 0.
-    for I in xrange(la+lb+lc+ld+1):
-        for J in xrange(ma+mb+mc+md+1):
-            for K in xrange(na+nb+nc+nd+1):
+    for I in range(la+lb+lc+ld+1):
+        for J in range(ma+mb+mc+md+1):
+            for K in range(na+nb+nc+nd+1):
                 sum = sum + Bx[I]*By[J]*Bz[K]*Fgamma(I+J+K,0.25*rpq2/delta) #needs Fgamma
 
     return 2*pow(pi,2.5)/(gamma1*gamma2*sqrt(gamma1+gamma2)) \
@@ -84,11 +89,11 @@
 def B_array(l1,l2,l3,l4,p,a,b,q,c,d,g1,g2,delta):
     Imax = l1+l2+l3+l4+1
     B = [0]*Imax
-    for i1 in xrange(l1+l2+1):
-        for i2 in xrange(l3+l4+1):
-            for r1 in xrange(i1/2+1):
-                for r2 in xrange(i2/2+1):
-                    for u in xrange((i1+i2)/2-r1-r2+1):
+    for i1 in range(l1+l2+1):
+        for i2 in range(l3+l4+1):
+            for r1 in range(i1/2+1):
+                for r2 in range(i2/2+1):
+                    for u in range((i1+i2)/2-r1-r2+1):
                         I = i1+i2-2*(r1+r2)-u
                         B[I] = B[I] + B_term(i1,i2,r1,r2,u,l1,l2,l3,l4, 
                                              p,a,b,q,c,d,g1,g2,delta)   #needs B_term
@@ -108,7 +113,7 @@
 def binomial_prefactor(s,ia,ib,xpa,xpb):
     "From Augspurger and Dykstra"
     sum = 0
-    for t in xrange(s+1):
+    for t in range(s+1):
         if s-ia <= t <= ib:
                 sum = sum + binomial(ia,s-t)*binomial(ib,t)* \
                   pow(xpa,ia-s+t)*pow(xpb,ib-t)
@@ -186,13 +191,13 @@
 
     ap = a
     delt = sum = 1./a
-    for i in xrange(ITMAX):
+    for i in range(ITMAX):
         ap=ap+1.
         delt=delt*x/ap
         sum=sum+delt
         if abs(delt) < abs(sum)*EPS: break
     else:
-        print 'a too large, ITMAX too small in gser'
+        print('a too large, ITMAX too small in gser')
     gamser=sum*exp(-x+a*log(x)-gln)
     return gamser,gln
 
@@ -207,7 +212,7 @@
     c=1./FPMIN
     d=1./b
     h=d
-    for i in xrange(1,ITMAX+1):
+    for i in range(1,ITMAX+1):
         an=-i*(i-a)
         b=b+2.
         d=an*d+b
@@ -219,7 +224,7 @@
         h=h*delt
         if abs(delt-1.) < EPS: break
     else:
-        print 'a too large, ITMAX too small in gcf'
+        print('a too large, ITMAX too small in gcf')
     gammcf=exp(-x+a*log(x)-gln)*h
     return gammcf,gln
 
@@ -234,7 +239,7 @@
     tmp=x+5.5
     tmp = tmp - (x+0.5)*log(tmp)
     ser=1.000000000190015 # don't you just love these numbers?!
-    for j in xrange(6):
+    for j in range(6):
         y = y+1
         ser = ser+cof[j]/y
     return -tmp+log(2.5066282746310005*ser/x);
--- PAOFLOW/src/externals/acbn0/src/scfuj.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/scfuj.py	(refactored)
@@ -133,7 +133,7 @@
                                 return float(alat[0]),paramMatrix
 
                         else:
-                                print 'No card!'
+                                print('No card!')
                                 return float(alat[0]),[[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]]
 
 
@@ -159,7 +159,7 @@
                 atmPosRegex1 = re.compile(r".*=.*\((.*)\)\n+",re.MULTILINE)
                 atmPos = atmPosRegex1.findall(lines1)
                 atmPosList = []
-                for i in atmPos:atmPosList.append(map(float,i.split()))
+                for i in atmPos:atmPosList.append(list(map(float,i.split())))
 
 				#Convert fractional atomic coordinates to cartesian coordinates using the lattice vectors
                 atmPosStr = ""
@@ -195,19 +195,19 @@
                 #For each atomic species
                 for atmSp in atmSpList:
 
-                        print "Creating acbn0 inpufile for %s"%atmSp
+                        print("Creating acbn0 inpufile for %s"%atmSp)
 
                         #Get orbital type to apply Hubbard correction
                         ql = get_orbital(atmSp.strip('0123456789'))
 
                         #Get list of all orbitals of type ql of the same species
                         eqOrbRegex = re.compile(r"state #\s*(\d*): atom.*\(%s.*\).*\(l=%d.*\)\n"%(atmSp.strip('0123456789'),ql),re.MULTILINE)
-                        eqOrbList = map(int, map(float,eqOrbRegex.findall(proj_lines)))
+                        eqOrbList = list(map(int, list(map(float,eqOrbRegex.findall(proj_lines)))))
                         red_basis = [x - 1 for x in eqOrbList]
 
                         #Get ones relevant for hubbard center
                         eqOrbRegex = re.compile(r"state #\s*(\d*): atom.*\(%s\s*\).*\(l=%d.*\)\n"%(atmSp,ql),re.MULTILINE)
-                        eqOrbList = map(int, map(float,eqOrbRegex.findall(proj_lines)));print eqOrbList
+                        eqOrbList = list(map(int, list(map(float,eqOrbRegex.findall(proj_lines)))));print(eqOrbList)
                         red_basis_for2e = [x - 1 for x in eqOrbList]
                         #Get list of orbitals of type l for one atom of the species
                         red_basis_2e = []
@@ -249,11 +249,11 @@
                         cmd="python %s/acbn0.py %s > /dev/null"%(subdir1,os.path.join(subdir,infnm))
 
 			try:
-                        	print "Starting python acbn0.py %s\n"%(os.path.join(subdir,infnm))
+                        	print("Starting python acbn0.py %s\n"%(os.path.join(subdir,infnm)))
 				subprocess.check_output([cmd],shell=True)
-	                        print "Finished python acbn0.py %s\n"%(os.path.join(subdir,infnm))
+	                        print("Finished python acbn0.py %s\n"%(os.path.join(subdir,infnm)))
 			except subprocess.CalledProcessError as e:
-				print "######### ABORTING ACBN0 LOOP ######### \n FAILED %s \n %s\n"%(cmd,e)
+				print("######### ABORTING ACBN0 LOOP ######### \n FAILED %s \n %s\n"%(cmd,e))
 				raise SystemExit
 
         acbn0_inFileList = gen_input(prefix,nspin)
@@ -281,12 +281,12 @@
 	                        acbn0_Uval = re.findall("U_eff\s*=\s*(\d+.\d+)",lines)[0]
 	                        Uvals[isp] = float(acbn0_Uval)
 			except Exception as e:
-				print "######### ABORTING ACBN0 LOOP ######### \n Could not find U values from acbn0 output"
+				print("######### ABORTING ACBN0 LOOP ######### \n Could not find U values from acbn0 output")
 				raise SystemExit
                 else:
                         Uvals[isp] = 0.001
 
-	print Uvals
+	print(Uvals)
 
 	#Record U values in a Log file
         if os.path.isfile(os.path.join(subdir,'%s_uValLog.log' % prefix)):
@@ -311,7 +311,7 @@
 	inputfile = fin.read()
 	fin.close()
 
-	print "Updating U values of %s with "%infile, Uvals
+	print("Updating U values of %s with "%infile, Uvals)
 		
         #Get species
         species = re.findall("(\w+).*UPF",inputfile)
@@ -347,7 +347,7 @@
 		try:
 			nspin = int(regEx.findall(scfInput)[0])
 		except Exception as e:
-			print "Detected Non-spin polarized calculation"
+			print("Detected Non-spin polarized calculation")
 			nspin = 1
 			pass
 
@@ -382,7 +382,7 @@
 		elif nspin == 2:
 			calcList = ['scf','nscf','pdos','PAO_bands_up','PAO_bands_down','acbn0']
 
-		print "List of calculations for each ACBN0 iteration ", str(calcList).strip('[]')
+		print("List of calculations for each ACBN0 iteration ", str(calcList).strip('[]'))
 
 		engine = {'scf':'espresso',
 			  'nscf':'espresso',
@@ -410,12 +410,12 @@
 				#	if calc == 'nscf':
 				#		os.system("cp -r %s %s"%(initDir, bakDir))
 							
-					print "Starting %s in %s"%(command, subdir)
+					print("Starting %s in %s"%(command, subdir))
 					subprocess.check_output([command],shell=True)
-					print "Finished %s in %s"%(command, subdir)
+					print("Finished %s in %s"%(command, subdir))
 
 				except subprocess.CalledProcessError as e:
-					print "######### ERROR IN ACBN0 LOOP CALCULATION ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+					print("######### ERROR IN ACBN0 LOOP CALCULATION ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
 				#	pass
 					raise SystemExit
 				if "PAO" in calc:
@@ -423,10 +423,10 @@
 						PAOOutput = file("%s_%s.out"%(prefix,calc),'r').read()
 						errorList = re.findall(r'.*error #\s*\d+.*\n.*\n',PAOOutput)
 						if len(errorList) > 0:
-							print "######### ABORTING ACBN0 LOOP ######### \n FAILED %s in %s\n PAO ERROR: \n%s"%(command, subdir,errorList[0])
+							print("######### ABORTING ACBN0 LOOP ######### \n FAILED %s in %s\n PAO ERROR: \n%s"%(command, subdir,errorList[0]))
 							raise SystemExit
 					except Exception as e:
-						print e 
+						print(e) 
 						pass
 
 
@@ -470,7 +470,7 @@
 			newUvals = oneRun(prefix,scfOne=False)
 		
 			#Check for convergence
-			for key in uVals.keys():
+			for key in list(uVals.keys()):
 				if abs(uVals[key]-newUvals[key]) > uThresh:
 					convergence = False
 					break;
@@ -492,7 +492,7 @@
 			newUvals = oneRun(prefix,scfOne=False)
 		
 			#Check for convergence
-			for key in uVals.keys():
+			for key in list(uVals.keys()):
 				if abs(uVals[key]-newUvals[key]) > uThresh:
 					convergence = False
 					break;
@@ -501,7 +501,7 @@
 
 
 	else:
-		print "Usage: $PATH/scfuj.py prefix"
+		print("Usage: $PATH/scfuj.py prefix")
 
 		
 
--- PAOFLOW/src/externals/elph/el-ph2.4.py	(original)
+++ PAOFLOW/src/externals/elph/el-ph2.4.py	(refactored)
@@ -38,7 +38,7 @@
 delta = degauss*13.6058                          # delta in eV
 delta = sys.argv[1]                          # delta in eV
 delta = float(delta)
-print 'delta = ',delta
+print('delta = ',delta)
 alat = 4.039e-10                             # lattice parameter in m
 N_Ef = 0.202                                  # in eV^-1 (2.75 Ry^-1 per atom per spin)
 mass = 2.513314e+10                           # in eV/c^2
@@ -61,7 +61,7 @@
 nawf = Hksp0.shape[1]                  # number of atomic orbitals
 nspin = Hksp0.shape[3]                 # number of spin components
 nktot = kq.shape[1]                    # number of k-points
-print 'nktot = ', nktot
+print('nktot = ', nktot)
 lambda_q = np.zeros(Hksp0.shape[3])
 
 ofile.write('\n**************************************************************************************************')
@@ -110,7 +110,7 @@
 
     lambda_q = gamma_q/2.0/np.pi**2/N_Ef*ELECTRONVOLT_SI/H_OVER_TPI/freq[v]**2 # the factor 1./2./np.pi comes from conversion from rad to Hz.
 
-    print 'lambda_q = ',lambda_q, ', freq = ',freq[v]/1.e+12,' THz,  gamma_q = ',gamma_q/1.0e+9,' GHz'
+    print('lambda_q = ',lambda_q, ', freq = ',freq[v]/1.e+12,' THz,  gamma_q = ',gamma_q/1.0e+9,' GHz')
     ofile.write('\n%f' %lambda_q)
     #start = time.time()
 
--- PAOFLOW/src/externals/genPAW/gen_extended_pao.py	(original)
+++ PAOFLOW/src/externals/genPAW/gen_extended_pao.py	(refactored)
@@ -1,5 +1,5 @@
 #from __future__ import print_function,division
-from __future__ import print_function
+
 __author__ = 'believe'
 
 
@@ -14,7 +14,7 @@
  import xml.etree.ElementTree as et
  import sys
  import scipy.io as sio
- import cPickle as pickle
+ import pickle as pickle
 
  #reads xml file
  #http://www.quantum-espresso.org/pseudopotentials/unified-pseudopotential-format
@@ -74,7 +74,7 @@
      if mesh != sizeaux:
         sys.exit('Error: The size of PP_R does not match mesh: %i != %i'%(sizeaux,mesh))
      xxaux = re.split('\n| ',rootaux.text)
-     rmesh  =np.array(map(float,filter(None,xxaux))) #In Bohrs
+     rmesh  =np.array(list(map(float,[_f for _f in xxaux if _f]))) #In Bohrs
      if mesh != len(rmesh):
        sys.exit('Error: wrong mesh size')
  psp["mesh"]=mesh
@@ -87,7 +87,7 @@
      if mesh != sizeaux:
         sys.exit('Error: The size of PP_RAB does not match mesh: %i != %i'%(sizeaux,mesh))
      xxaux = re.split('\n| ',rootaux.text)
-     rmesh  =np.array(map(float,filter(None,xxaux))) #In Bohrs
+     rmesh  =np.array(list(map(float,[_f for _f in xxaux if _f]))) #In Bohrs
      if mesh != len(rmesh):
        sys.exit('Error: wrong mesh size')
  psp["rab"]=rmesh
@@ -101,7 +101,7 @@
          kkbeta[ibeta] = int(rootaux.attrib['size'])
          lll[ibeta]    = int(rootaux.attrib['angular_momentum'])
          xxaux         = re.split('\n| ',rootaux.text)
-         rmesh         = np.array(map(float,filter(None,xxaux))) 
+         rmesh         = np.array(list(map(float,[_f for _f in xxaux if _f]))) 
          if kkbeta[ibeta] != len(rmesh):
            sys.exit('Error: wrong mesh size')
      psp["beta_"+str(ibeta+1)]=rmesh
@@ -123,7 +123,7 @@
    lchi.append(int(node.attrib['l']))
    oc.append(float(node.attrib['occupation']))
    xxaux = re.split('\n| ',node.text)
-   wfc_aux  =np.array([map(float,filter(None,xxaux))])
+   wfc_aux  =np.array([list(map(float,[_f for _f in xxaux if _f]))])
    chi = np.concatenate((chi,wfc_aux))
  if nwfc != chi.shape[0]: 
    sys.error('Error: wrong number of PAOs')
@@ -151,7 +151,7 @@
             full_aewfc_l.append(int(rootaux.attrib['l']))
             full_aewfc_label.append(rootaux.attrib['label'])
             xxaux         = re.split('\n| ',rootaux.text)
-            rmesh         = np.array([map(float,filter(None,xxaux))]) 
+            rmesh         = np.array([list(map(float,[_f for _f in xxaux if _f]))]) 
             if sizeaux != rmesh.shape[1]: sys.exit('Error: wrong mesh size')
             full_aewfc    = np.concatenate((full_aewfc,rmesh))
     psp["full_aewfc"]       =np.transpose(full_aewfc)
@@ -168,7 +168,7 @@
             full_pswfc_l.append(int(rootaux.attrib['l']))
             full_pswfc_label.append(rootaux.attrib['label'])
             xxaux         = re.split('\n| ',rootaux.text)
-            rmesh         = np.array([map(float,filter(None,xxaux))]) 
+            rmesh         = np.array([list(map(float,[_f for _f in xxaux if _f]))]) 
             if sizeaux != rmesh.shape[1]: sys.exit('Error: wrong mesh size')
             full_pswfc    = np.concatenate((full_pswfc,rmesh))
     psp["full_pswfc"]       =np.transpose(full_pswfc)
@@ -384,10 +384,10 @@
 		paoList = paoRE.findall(ld1FileString)
 
 		llabels	= [x[0] for i,x in enumerate(paoList)];print("llabels:", llabels)
-		ll	= map(int,[x[1] for i,x in enumerate(paoList)]);print("ll:", ll)
-		rcut	= max(map(float,[x[4] for i,x in enumerate(paoList)]));print("rcut:", rcut)
-		pseudo_e= map(float, [x[3] for i,x in enumerate(paoList)]);print("pseudo_e:", pseudo_e)
-		occups  = map(float,[x[2] for i,x in enumerate(paoList)]);print("occupations:", occups)
+		ll	= list(map(int,[x[1] for i,x in enumerate(paoList)]));print("ll:", ll)
+		rcut	= max(list(map(float,[x[4] for i,x in enumerate(paoList)])));print("rcut:", rcut)
+		pseudo_e= list(map(float, [x[3] for i,x in enumerate(paoList)]));print("pseudo_e:", pseudo_e)
+		occups  = list(map(float,[x[2] for i,x in enumerate(paoList)]));print("occupations:", occups)
 
 		
 		PS2AE_print(UPF_fullpath,wfc_ae_fullpath,llabels,ll,rcut,pseudo_e)
@@ -450,7 +450,7 @@
 			r1=re.compile(r"\!cases.*\n!.*",re.DOTALL)
 			r1String = r1.findall(ld1Str)[0].split('\n')[1:]
 
-			wfc_combinations = [map(int,x.strip('!').split()) for i, x in enumerate(r1String) if len(x) > 0]
+			wfc_combinations = [list(map(int,x.strip('!').split())) for i, x in enumerate(r1String) if len(x) > 0]
 		except:
 			print("Error in case specification of ld1.x input file")
 			raise SystemExit
--- PAOFLOW/src/externals/genPAW/radial_integral.py	(original)
+++ PAOFLOW/src/externals/genPAW/radial_integral.py	(refactored)
@@ -1,4 +1,4 @@
-from __future__ import print_function
+
 __author__ = 'believe'
 
 import sys
--- PAOFLOW/src/externals/genPAW/read_UPF.py	(original)
+++ PAOFLOW/src/externals/genPAW/read_UPF.py	(refactored)
@@ -7,7 +7,7 @@
 
 #Reads QE pseudopotential files for UPF v2.0.1
 
-from __future__ import division
+
 import numpy as np
 
 ##################################################
@@ -17,7 +17,7 @@
  import xml.etree.ElementTree as et
  import sys
  import scipy.io as sio
- import cPickle as pickle
+ import pickle as pickle
 
  #reads xml file
  #http://www.quantum-espresso.org/pseudopotentials/unified-pseudopotential-format
@@ -77,7 +77,7 @@
      if mesh != sizeaux:
         sys.exit('Error: The size of PP_R does not match mesh: %i != %i'%(sizeaux,mesh))
      xxaux = re.split('\n| ',rootaux.text)
-     rmesh  =np.array(map(float,filter(None,xxaux))) #In Bohrs
+     rmesh  =np.array(list(map(float,[_f for _f in xxaux if _f]))) #In Bohrs
      if mesh != len(rmesh):
        sys.exit('Error: wrong mesh size')
  psp["mesh"]=mesh
@@ -90,7 +90,7 @@
      if mesh != sizeaux:
         sys.exit('Error: The size of PP_RAB does not match mesh: %i != %i'%(sizeaux,mesh))
      xxaux = re.split('\n| ',rootaux.text)
-     rmesh  =np.array(map(float,filter(None,xxaux))) #In Bohrs
+     rmesh  =np.array(list(map(float,[_f for _f in xxaux if _f]))) #In Bohrs
      if mesh != len(rmesh):
        sys.exit('Error: wrong mesh size')
  psp["rab"]=rmesh
@@ -104,7 +104,7 @@
          kkbeta[ibeta] = int(rootaux.attrib['size'])
          lll[ibeta]    = int(rootaux.attrib['angular_momentum'])
          xxaux         = re.split('\n| ',rootaux.text)
-         rmesh         = np.array(map(float,filter(None,xxaux))) 
+         rmesh         = np.array(list(map(float,[_f for _f in xxaux if _f]))) 
          if kkbeta[ibeta] != len(rmesh):
            sys.exit('Error: wrong mesh size')
      psp["beta_"+str(ibeta+1)]=rmesh
@@ -121,17 +121,17 @@
  lchi= []
  oc  = []
  for node in pswfc:
-   print node.tag, node.attrib['l'],node.attrib['label']
+   print(node.tag, node.attrib['l'],node.attrib['label'])
    els.append(node.attrib['label'])
    lchi.append(int(node.attrib['l']))
    oc.append(float(node.attrib['occupation']))
    xxaux = re.split('\n| ',node.text)
-   wfc_aux  =np.array([map(float,filter(None,xxaux))])
+   wfc_aux  =np.array([list(map(float,[_f for _f in xxaux if _f]))])
    chi = np.concatenate((chi,wfc_aux))
  if nwfc != chi.shape[0]: 
    sys.error('Error: wrong number of PAOs')
  else:
-   print 'Number of radial wavefunctions found: %i' % chi.shape[0]
+   print('Number of radial wavefunctions found: %i' % chi.shape[0])
  psp["chi"] =np.transpose(chi)
  psp["els"] =els
  psp["lchi"]=lchi
@@ -154,7 +154,7 @@
             full_aewfc_l.append(int(rootaux.attrib['l']))
             full_aewfc_label.append(rootaux.attrib['label'])
             xxaux         = re.split('\n| ',rootaux.text)
-            rmesh         = np.array([map(float,filter(None,xxaux))]) 
+            rmesh         = np.array([list(map(float,[_f for _f in xxaux if _f]))]) 
             if sizeaux != rmesh.shape[1]: sys.exit('Error: wrong mesh size')
             full_aewfc    = np.concatenate((full_aewfc,rmesh))
     psp["full_aewfc"]       =np.transpose(full_aewfc)
@@ -171,7 +171,7 @@
             full_pswfc_l.append(int(rootaux.attrib['l']))
             full_pswfc_label.append(rootaux.attrib['label'])
             xxaux         = re.split('\n| ',rootaux.text)
-            rmesh         = np.array([map(float,filter(None,xxaux))]) 
+            rmesh         = np.array([list(map(float,[_f for _f in xxaux if _f]))]) 
             if sizeaux != rmesh.shape[1]: sys.exit('Error: wrong mesh size')
             full_pswfc    = np.concatenate((full_pswfc,rmesh))
     psp["full_pswfc"]       =np.transpose(full_pswfc)
--- PAOFLOW/src/externals/genPAW_ld1/UPF_GaussFit2.py	(original)
+++ PAOFLOW/src/externals/genPAW_ld1/UPF_GaussFit2.py	(refactored)
@@ -11,7 +11,7 @@
 import sys
 import numpy as np
 import argparse
-import StringIO
+import io
 from math import *
 from scipy.optimize import leastsq
 from scipy.optimize import minimize
@@ -71,38 +71,38 @@
             leastsq(target, params0, args=(r, rab, wfc, l), full_output=1, \
             maxfev=10000, ftol=1e-10, xtol=1e-10)
         if ier > 0:
-            print "ERROR: ier=", ier, "mesg=", mesg
-            print "ERROR: info[nfev]=", info["nfev"]
-            print "ERROR: info[fvec]=", sum(info["fvec"]**2.0)
+            print("ERROR: ier=", ier, "mesg=", mesg)
+            print("ERROR: info[nfev]=", info["nfev"])
+            print("ERROR: info[fvec]=", sum(info["fvec"]**2.0))
     else: # minimize
         opt = minimize(target_squared, params0, args=(r, rab, wfc, l), \
                        method='CG', tol=1e-10)
         #opt = basinhopping(target_squared, params0, minimizer_kwargs={'args':(r, rab, wfc, l)})
         params = opt.x
         if not opt.success:
-           print "ERROR: opt.status=", opt.status
-           print "ERROR: opt.message=", opt.message
-           print "ERROR: opt.nfev=", opt.nfev
-           print "ERROR: opt.fun=", opt.fun
+           print("ERROR: opt.status=", opt.status)
+           print("ERROR: opt.message=", opt.message)
+           print("ERROR: opt.nfev=", opt.nfev)
+           print("ERROR: opt.fun=", opt.fun)
 
 
     alpha, beta = params[0:2]
     n = sqrt(fact2(2*l+1)/(4.0*pi))
     coeffs = params[2:] * n
     expon = []
-    print "alpha = %f, beta = %f" % (alpha, beta)
+    print("alpha = %f, beta = %f" % (alpha, beta))
     for (j,coeff) in enumerate(coeffs):
         zeta = alpha/beta**j
         expon.append(zeta)
-        print "coeff = %f,  zeta = %f" % (coeff, zeta)
+        print("coeff = %f,  zeta = %f" % (coeff, zeta))
 
     with open("wfc"+label+".dat", "wt") as f:
         gto_r = gto(r, l, params)
-        for i in xrange(len(wfc)):
+        for i in range(len(wfc)):
             f.write("%f %f %f\n" % (r[i], wfc[i], r[i]*gto_r[i]))
     pylab.plot(r, wfc, '.', label=label+"_orig")
     pylab.plot(r, r*gto(r, l, params), label=label+"_fit")
-    print "INFO: fit result:", target_squared(params, r, rab, wfc, l)
+    print("INFO: fit result:", target_squared(params, r, rab, wfc, l))
 
     return coeffs, expon
 
@@ -113,59 +113,59 @@
 #======================================================================
 def print_python_block(bfile, label, l, coeffs, expon):
     nzeta = len(coeffs)
-    print >>bfile, "# label=", label, "l=", l
+    print("# label=", label, "l=", l, file=bfile)
 
     if l == 0:
-        print >>bfile, "[["
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,0,coeffs[n],expon[n])
-        print >>bfile, "]],"
+        print("[[", file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,0,coeffs[n],expon[n]), file=bfile)
+        print("]],", file=bfile)
 
     elif l == 1:
-        print >>bfile, "[["
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,1,coeffs[n],expon[n])
-        print >>bfile, "], ["
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,1,0,coeffs[n],expon[n])
-        print >>bfile, "], ["
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (1,0,0,coeffs[n],expon[n])
-        print >>bfile, "]],"
+        print("[[", file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,1,coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,1,0,coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (1,0,0,coeffs[n],expon[n]), file=bfile)
+        print("]],", file=bfile)
 
     elif l == 2:
-        print >>bfile, "[["
+        print("[[", file=bfile)
 
         fact = 0.5/sqrt(3.0)
         for n in range(nzeta):  # 1/(2.0*sqrt(3))*(2*z2 - x2 - y2)
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,2,2.0*fact*coeffs[n],expon[n])
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,2,0,-fact*coeffs[n],expon[n])
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (2,0,0,-fact*coeffs[n],expon[n])
-        print >>bfile, "], ["
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,0,2,2.0*fact*coeffs[n],expon[n]), file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,2,0,-fact*coeffs[n],expon[n]), file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (2,0,0,-fact*coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
 
         for n in range(nzeta): # xz
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (1,0,1,coeffs[n],expon[n])
-        print >>bfile, "], ["
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (1,0,1,coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
 
         for n in range(nzeta): # yz
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,1,1,coeffs[n],expon[n])
-        print >>bfile, "], ["
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,1,1,coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
 
         fact = 0.5
         for n in range(nzeta): # 1/2 * (x2 - y2)
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (0,2,0,fact*coeffs[n],expon[n])
-        for n in range(nzeta):
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (2,0,0,-fact*coeffs[n],expon[n])
-        print >>bfile, "], ["
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (0,2,0,fact*coeffs[n],expon[n]), file=bfile)
+        for n in range(nzeta):
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (2,0,0,-fact*coeffs[n],expon[n]), file=bfile)
+        print("], [", file=bfile)
 
         for n in range(nzeta): # xy
-            print >>bfile, "   (%i,%i,%i,%20.10f,%20.10f)," % (1,1,0,coeffs[n],expon[n])
-        print >>bfile, "]],"
+            print("   (%i,%i,%i,%20.10f,%20.10f)," % (1,1,0,coeffs[n],expon[n]), file=bfile)
+        print("]],", file=bfile)
 
     elif l == 3:
-        print "l=3 not implemented yet!"
+        print("l=3 not implemented yet!")
 
     return
 
@@ -192,17 +192,17 @@
     root = ET.fromstring(xml_file_content)
     version = root.attrib["version"]
     upfver = int(version.split(".")[0])
-    print "INFO: fitting file", xml_file, "with", nzeta, "gaussians"
-    print "INFO: UPF version", upfver, "detected"
-except Exception, inst:
-    print "Unexpected error opening %s: %s" % (xml_file, inst)
+    print("INFO: fitting file", xml_file, "with", nzeta, "gaussians")
+    print("INFO: UPF version", upfver, "detected")
+except Exception as inst:
+    print("Unexpected error opening %s: %s" % (xml_file, inst))
     sys.exit(1)
 
 
 #### get element name ####
 if upfver == 1:
     text = root.find('PP_HEADER').text.split()
-    for i in xrange(len(text)):
+    for i in range(len(text)):
         if text[i] == 'Element':
             element = text[i-1].strip()
             break
@@ -210,8 +210,8 @@
     element = root.find('PP_HEADER').attrib["element"].strip()
 
 atno = ELEMENTS[element].number
-print "INFO: element=", element, "atomic number=", atno
-print
+print("INFO: element=", element, "atomic number=", atno)
+print()
 
 
 #### open basis file ####
@@ -233,15 +233,15 @@
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
    
     chis = root.find('PP_PSWFC')
     if chis is None:
-         print "ERROR: cannot find PP_PSWFC tag"
+         print("ERROR: cannot find PP_PSWFC tag")
          sys.exit(1)
-    data = StringIO.StringIO(chis.text)
+    data = io.StringIO(chis.text)
     nlines = len(r)/4
     if len(r) % 4 != 0: nlines += 1
 
@@ -254,26 +254,26 @@
         occ = float(occ)
         wfc = []
 
-        for i in xrange(nlines):
-            wfc.extend(map(float, data.readline().split()))
+        for i in range(nlines):
+            wfc.extend(list(map(float, data.readline().split())))
         wfc = np.array(wfc)
 
         if exclude.find(label) >= 0:
-            print "INFO: skipping", label
+            print("INFO: skipping", label)
             continue
 
         norm = sum(wfc*wfc*rab)
-        print "INFO: fitting pswfc", label, "l=", l, "norm=", norm
+        print("INFO: fitting pswfc", label, "l=", l, "norm=", norm)
         #wfc *= 1.0/sqrt(norm)
         coeffs, expon = fit(nzeta, label, l, r, rab, wfc)
         print_python_block(basisfile, label, l, coeffs, expon)
-        print
+        print()
  
     betas = root.find('PP_NONLOCAL/PP_BETA')
     if betas is None:
-         print "ERROR: cannot find PP_BETA tag"
+         print("ERROR: cannot find PP_BETA tag")
          sys.exit(1)
-    data = StringIO.StringIO(betas.text)
+    data = io.StringIO(betas.text)
 
     while True:
         line = data.readline()
@@ -288,25 +288,25 @@
         if npoints % 4 != 0: nlines += 1
         beta = []
 
-        for i in xrange(nlines):
-            beta.extend(map(float, data.readline().split()))
-        print beta
+        for i in range(nlines):
+            beta.extend(list(map(float, data.readline().split())))
+        print(beta)
         beta = np.array(beta)
         f = open("beta_%i_%i.dat" % (ibeta, l), 'w')
-        for i in xrange(len(beta)):
+        for i in range(len(beta)):
             f.write("%f %f\n" % (r[i], beta[i]))
         f.close()
         line = data.readline()
-        print line
+        print(line)
         line = data.readline()
-        print line
+        print(line)
  
 else:
     pot = root.find('PP_LOCAL')
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
 
@@ -314,7 +314,7 @@
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal_ae.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
 
@@ -326,7 +326,7 @@
 
         label = chi.attrib["label"]
         if exclude.find(label) >= 0:
-            print "INFO: skipping", label
+            print("INFO: skipping", label)
             continue
         l = int(chi.attrib["l"])
         wfc = [float(x) for x in chi.text.split()]
@@ -334,11 +334,11 @@
         wfc = np.array(wfc)
        
         norm = sum(wfc*wfc*rab)
-        print "INFO: fitting pswfc", label, "l=", l, "norm=", norm
+        print("INFO: fitting pswfc", label, "l=", l, "norm=", norm)
         #wfc *= 1.0/sqrt(norm)
         coeffs, expon = fit(nzeta, label, l, r, rab, wfc)
         print_python_block(basisfile, label, l, coeffs, expon)
-        print
+        print()
 
 basisfile.write("]}\n")
 basisfile.close()
@@ -348,6 +348,6 @@
 pylab.xlabel('r (bohrradius)')
 pylab.ylabel('radial wfc')
 pylab.show()
-print "INFO: file", basisfile.name, "created!"
-
-
+print("INFO: file", basisfile.name, "created!")
+
+
--- PAOFLOW/src/externals/genPAW_ld1/elements.py	(original)
+++ PAOFLOW/src/externals/genPAW_ld1/elements.py	(refactored)
@@ -68,7 +68,7 @@
 
 """
 
-from __future__ import division, print_function
+
 
 __version__ = '2015.01.29'
 __docformat__ = 'restructuredtext en'
@@ -210,7 +210,7 @@
         """Return mass number of most abundant natural stable isotope."""
         nominalmass = 0
         maxabundance = 0
-        for massnum, iso in self.isotopes.items():
+        for massnum, iso in list(self.isotopes.items()):
             if iso.abundance > maxabundance:
                 maxabundance = iso.abundance
                 nominalmass = massnum
@@ -224,7 +224,7 @@
     @lazyattr
     def exactmass(self):
         """Return relative atomic mass calculated from isotopic composition."""
-        return sum(iso.mass * iso.abundance for iso in self.isotopes.values())
+        return sum(iso.mass * iso.abundance for iso in list(self.isotopes.values()))
 
     @lazyattr
     def eleconfig_dict(self):
@@ -241,7 +241,7 @@
     def eleshells(self):
         """Return number of electrons in shell as tuple."""
         eleshells = [0, 0, 0, 0, 0, 0, 0]
-        for key, val in self.eleconfig_dict.items():
+        for key, val in list(self.eleconfig_dict.items()):
             eleshells[key[0] - 1] += val
         return tuple(ele for ele in eleshells if ele)
 
@@ -266,7 +266,7 @@
 
         mass = 0.0
         frac = 0.0
-        for iso in self.isotopes.values():
+        for iso in list(self.isotopes.values()):
             mass += iso.abundance * iso.mass
             frac += iso.abundance
         if abs(mass - self.mass) > 0.03:
@@ -2565,15 +2565,15 @@
         );
     """]
 
-    for key, label in PERIODS.items():
+    for key, label in list(PERIODS.items()):
         sql.append("""INSERT INTO "period" VALUES (%i, '%s', NULL);""" % (
             key, label))
 
-    for key, (label, descr) in GROUPS.items():
+    for key, (label, descr) in list(GROUPS.items()):
         sql.append("""INSERT INTO "group" VALUES (%i, '%s', '%s');""" % (
             key, label, descr))
 
-    for data in BLOCKS.items():
+    for data in list(BLOCKS.items()):
         sql.append("""INSERT INTO "block" VALUES ('%s', '%s');""" % data)
 
     for series in sorted(SERIES):
@@ -2597,13 +2597,13 @@
                 linelen=74, indent=0, joinstr="\n ")))
 
     for ele in ELEMENTS:
-        for iso in ele.isotopes.values():
+        for iso in list(ele.isotopes.values()):
             sql.append(
                 """INSERT INTO "isotope" VALUES (%i, %i, %.10f, %.8f);""" % (
                     ele.number, iso.massnumber, iso.mass, iso.abundance))
 
     for ele in ELEMENTS:
-        for (shell, subshell), count in ele.eleconfig_dict.items():
+        for (shell, subshell), count in list(ele.eleconfig_dict.items()):
             sql.append(
                 """INSERT INTO "eleconfig" VALUES (%i, %i, '%s', %i);""" % (
                     ele.number, shell, subshell, count))
--- PAOFLOW/src/externals/transportPAO/tests/test05/plot.py	(original)
+++ PAOFLOW/src/externals/transportPAO/tests/test05/plot.py	(refactored)
@@ -6,14 +6,14 @@
 a_k = np.zeros((300,191),dtype=float)
 Efermi = 0.0#12.79 
 
-for i in xrange(300):
+for i in range(300):
     a = f.readline()
     aux = a.split()
     a = np.array(aux,dtype="float32")
     a_k[i,:] = a - Efermi
 
 #print (a_k[0,:])
-print (a_k.shape[0],a_k.shape[1])
+print((a_k.shape[0],a_k.shape[1]))
 
 
 plt.matshow(a_k,fignum=100)
--- PAOFLOW/testing/check_test.py	(original)
+++ PAOFLOW/testing/check_test.py	(refactored)
@@ -85,7 +85,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -114,19 +114,19 @@
             allDataResult = result = RED+'FAIL'+RESET
 
         if showErrors:
-            print('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError))
+            print(('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError)))
         showFileResult_tmp = showFileResult
         if result == RED+'FAIL'+RESET:
            showFileResult_tmp = True 
         if showFileResult_tmp:
-            print('\t[%s] ---------- %s' % (result,datFiles[i]))
+            print(('\t[%s] ---------- %s' % (result,datFiles[i])))
         showFileResult_tmp = showFileResult
 
     if showErrors:
-        print('The maximum absolute error in %s was %E in %s' % (test_set_dir+'/'+subdir, maxError, datFiles[maxErrorIndex]))
-        print('The maximum relative error in %s was %E in %s' % (test_set_dir+'/'+subdir, maxRelError, datFiles[maxRelErrorIndex]))
+        print(('The maximum absolute error in %s was %E in %s' % (test_set_dir+'/'+subdir, maxError, datFiles[maxErrorIndex])))
+        print(('The maximum relative error in %s was %E in %s' % (test_set_dir+'/'+subdir, maxRelError, datFiles[maxRelErrorIndex])))
 
-    print('[%s] ---------- %s' % ( allDataResult,test_set_dir+'/'+subdir))
+    print(('[%s] ---------- %s' % ( allDataResult,test_set_dir+'/'+subdir)))
 
 
 def main():
@@ -147,7 +147,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/testing/run_test.py	(original)
+++ PAOFLOW/testing/run_test.py	(refactored)
@@ -69,10 +69,10 @@
         command = get_exeCmd(engine[calc.split("_")[0]],calc.split("_")[0],fileList[n])
         n += 1
         try:
-            print "%s in %s"%(command, subdir)
+            print("%s in %s"%(command, subdir))
             subprocess.check_output([command],shell=True)
         except subprocess.CalledProcessError as e:
-            print "######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+            print("######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
             raise SystemExit
     return
 
@@ -97,7 +97,7 @@
 
             subprocess.check_output([command],shell=True)
         except subprocess.CalledProcessError as e:
-            print "######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+            print("######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
             raise SystemExit
     return
 
@@ -118,32 +118,32 @@
         if refPattern[len(refPattern)-1] != '/':
             refPattern += '/'
 
-    for n in xrange(len(pwdir)):
+    for n in range(len(pwdir)):
         os.chdir(pwdir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
 
         try:
             run_pw(subdir)
         except:
-            print('Exception in %s'%subdir)
+            print(('Exception in %s'%subdir))
             quit()
         os.chdir('../../')
 
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
 
         try:
             run_pao(subdir)
         except:
-            print('Exception in %s'%subdir)
+            print(('Exception in %s'%subdir))
             quit()
         verifyData(subdir, refPattern)
         os.chdir('../../')
 
         reset=time.time()
 
-    print('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10))
+    print(('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10)))
 
 if __name__ == "__main__":
     main()
--- PAOFLOW/testing/nosmear/check_test.py	(original)
+++ PAOFLOW/testing/nosmear/check_test.py	(refactored)
@@ -32,7 +32,7 @@
     tolerance = 0.005  # Percentage that error can deviate from average to pass tests
     ######### End User Defined Variables ########
 
-    print('Verifying .dat files for %s' % subdir)
+    print(('Verifying .dat files for %s' % subdir))
 
     # Get new data files and existing reference data files
     datFiles = glob.glob('*.dat')
@@ -78,7 +78,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -107,15 +107,15 @@
             allDataResult = result = 'FAIL'
 
         if showErrors:
-            print('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError))
+            print(('\t%s:\n\t\tMean Absolute Errors: %s\n\t\tRelative Errors: %s' % (datFiles[i], absoluteError, relativeError)))
         if showFileResult:
-            print('\t%s ---------- [%s]\n' % (datFiles[i], result))
+            print(('\t%s ---------- [%s]\n' % (datFiles[i], result)))
 
     if showErrors:
-        print('The maximum absolute error in %s was %E in %s' % (subdir, maxError, datFiles[maxErrorIndex]))
-        print('The maximum relative error in %s was %E in %s' % (subdir, maxRelError, datFiles[maxRelErrorIndex]))
+        print(('The maximum absolute error in %s was %E in %s' % (subdir, maxError, datFiles[maxErrorIndex])))
+        print(('The maximum relative error in %s was %E in %s' % (subdir, maxRelError, datFiles[maxRelErrorIndex])))
 
-    print('%s ---------- [%s]\n' % (subdir, allDataResult))
+    print(('%s ---------- [%s]\n' % (subdir, allDataResult)))
 
 
 def main():
@@ -136,7 +136,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/testing/nosmear/run_test.py	(original)
+++ PAOFLOW/testing/nosmear/run_test.py	(refactored)
@@ -65,10 +65,10 @@
         command = get_exeCmd(engine[calc.split("_")[0]],calc.split("_")[0],fileList[n])
         n += 1
         try:
-            print "%s in %s"%(command, subdir)
+            print("%s in %s"%(command, subdir))
             subprocess.check_output([command],shell=True)
         except subprocess.CalledProcessError as e:
-            print "######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e)
+            print("######### SEQUENCE ######### \n FAILED %s in %s\n %s\n"%(command, subdir,e))
             raise SystemExit
     return
 
@@ -88,20 +88,20 @@
         if refPattern[len(refPattern)-1] != '/':
             refPattern += '/'
 
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         try:
             oneRun(subdir)
         except:
-            print('Exception in %s'%subdir)
+            print(('Exception in %s'%subdir))
             quit()
         verifyData(subdir, refPattern)
         os.chdir('../')
-        print('test run in %5s sec ' %str('%.3f' %(time.time()-reset)).rjust(10))
+        print(('test run in %5s sec ' %str('%.3f' %(time.time()-reset)).rjust(10)))
         reset=time.time()
 
-    print('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10))
+    print(('all test runs in %5s sec ' %str('%.3f' %(time.time()-start)).rjust(10)))
 
 if __name__ == "__main__":
     main()
--- PAOFLOW/examples/check_test.py	(original)
+++ PAOFLOW/examples/check_test.py	(refactored)
@@ -78,7 +78,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -136,7 +136,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/src/PAOFLOW.py	(original)
+++ PAOFLOW/src/PAOFLOW.py	(refactored)
@@ -288,7 +288,7 @@
             # Check projectability and decide bnd
     
             bnd = 0
-            for n in xrange(nbnds):
+            for n in range(nbnds):
                 if Pn[n] > pthr:
                     bnd += 1
             Pn = None
@@ -371,37 +371,37 @@
             else:
                 if nspin == 1:
                     f=open(os.path.join(inputpath,'kham.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,0]),np.imag(Hks[i,j,ik,0])))
                     f.close()
                 elif nspin == 2:
                     f=open(os.path.join(inputpath,'kham_up.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,0]),np.imag(Hks[i,j,ik,0])))
                     f.close()
                     f=open(os.path.join(inputpath,'kham_down.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Hks[i,j,ik,1]),np.imag(Hks[i,j,ik,1])))
                     f.close()
                 if non_ortho:
                     f=open(os.path.join(inputpath,'kovp.txt'),'w')
-                    for ik in xrange(nkpnts):
-                        for i in xrange(nawf):
-                            for j in xrange(nawf):
+                    for ik in range(nkpnts):
+                        for i in range(nawf):
+                            for j in range(nawf):
                                 f.write('%20.13f %20.13f \n' %(np.real(Sks[i,j,ik]),np.imag(Sks[i,j,ik])))
                     f.close()
             f=open(os.path.join(inputpath,'k.txt'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 f.write('%20.13f %20.13f %20.13f \n' %(kpnts[ik,0],kpnts[ik,1],kpnts[ik,2]))
             f.close()
             f=open(os.path.join(inputpath,'wk.txt'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 f.write('%20.13f \n' %(kpnts_wght[ik]))
             f.close()
     
@@ -489,8 +489,8 @@
             # Add external fields or non scf ACBN0 correction
             tau_wf = np.zeros((nawf,3),dtype=float)
             l=0
-            for n in xrange(natoms):
-                for i in xrange(naw[n]):
+            for n in range(natoms):
+                for i in range(naw[n]):
                     tau_wf[l,:] = tau[n,:]
                     l += 1
     
@@ -586,7 +586,7 @@
             # Define k-point mesh for bands interpolation
             kq = kpnts_interpolation_mesh(ibrav,alat,a_vectors,b_vectors,nk,inputpath)
             nkpi=kq.shape[1]
-            for n in xrange(nkpi):
+            for n in range(nkpi):
                 kq[:,n]=np.dot(kq[:,n],b_vectors)
     
             # Compute the bands along the path in the IBZ
@@ -1093,7 +1093,7 @@
             # Compute velocities for Boltzmann transport
             #----------------------
             velkp = np.zeros((pksp.shape[0],3,bnd,nspin),dtype=float)
-            for n in xrange(bnd):
+            for n in range(bnd):
                 velkp[:,:,n,:] = np.real(pksp[:,:,n,n,:])
 
 
@@ -1106,9 +1106,9 @@
                     # Find critical points (grad(E_kn)=0)
                     #----------------------
                     f=open(os.path.join(inputpath,'critical_points.dat'),'w')
-                    for ik in xrange(nk1*nk2*nk3):
-                        for n in xrange(bnd):
-                            for ipin in xrange(nspin):
+                    for ik in range(nk1*nk2*nk3):
+                        for n in range(bnd):
+                            for ipin in range(nspin):
                                 if  np.abs(velkp_full[ik,0,n,ispin]) < 1.e-2 and \
                                     np.abs(velkp_full[ik,1,n,ispin]) < 1.e-2 and \
                                     np.abs(velkp_full[ik,2,n,ispin]) < 1.e-2:
@@ -1161,7 +1161,7 @@
                 #----------------------
                 # PDOS calculation
                 #----------------------    
-                for ispin in xrange(nspin):
+                for ispin in range(nspin):
                     do_pdos_calc_adaptive(E_k[:,:,ispin],emin,emax,deltakp[:,:,ispin],v_k[:,:,:,ispin],
                                           nk1,nk2,nk3,nawf,ispin,smearing,inputpath)
 
@@ -1229,7 +1229,7 @@
         #----------------------
         if spin_Hall:
             if dftSO == False: sys.exit('full relativistic calculation with SO needed')
-            for n in xrange(s_tensor.shape[0]):
+            for n in range(s_tensor.shape[0]):
                 ipol = s_tensor[n][0]
                 jpol = s_tensor[n][1]
                 spol = s_tensor[n][2]
@@ -1285,18 +1285,18 @@
                 if rank == 0:
                     shc *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                     f=open(os.path.join(inputpath,'shcEf_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e \n' %(ene[n],shc[n]))
                     f.close()
     
                     if  ac_cond_spin:
                         sigxy *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                         f=open(os.path.join(inputpath,'SCDi_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.imag(ene_ac[n]*sigxy[n]/105.4571)))  #convert energy in freq (1/hbar in cgs units)
                         f.close()
                         f=open(os.path.join(inputpath,'SCDr_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.real(sigxy[n])))
                         f.close()
 
@@ -1321,7 +1321,7 @@
         if Berry:
             if dftSO == False: sys.exit('full relativistic calculation with SO needed')
  
-            for n in xrange(a_tensor.shape[0]):
+            for n in range(a_tensor.shape[0]):
                 ipol = a_tensor[n][0]
                 jpol = a_tensor[n][1]
                 ene,ahc,Om_k = do_Berry_curvature(E_k,pksp,nk1,nk2,nk3,npool,ipol,jpol,
@@ -1350,18 +1350,18 @@
                 if rank == 0:
                     ahc *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                     f=open(os.path.join(inputpath,'ahcEf_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e \n' %(ene[n],ahc[n]))
                     f.close()
     
                     if ac_cond_Berry:
                         sigxy *= 1.0e8*ANGSTROM_AU*ELECTRONVOLT_SI**2/H_OVER_TPI/omega
                         f=open(os.path.join(inputpath,'MCDi_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.imag(ene_ac[n]*sigxy[n]/105.4571)))  #convert energy in freq (1/hbar in cgs units)
                         f.close()
                         f=open(os.path.join(inputpath,'MCDr_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' %(ene_ac[n],np.real(sigxy[n])))
                         f.close()
     
@@ -1380,7 +1380,7 @@
         # Compute transport quantities (conductivity, Seebeck and thermal electrical conductivity)
         #----------------------
         if Boltzmann:
-            for ispin in xrange(nspin):
+            for ispin in range(nspin):
     
                 if smearing == None:
                     ene,L0,L1,L2 = do_Boltz_tensors(E_k,velkp,kq_wght,temp,ispin,deltakp,smearing,t_tensor)
@@ -1395,7 +1395,7 @@
                       (ELECTRONVOLT_SI/(H_OVER_TPI**2*BOHR_RADIUS_SI))*1.0e-21
                 if rank == 0:
                     f=open(os.path.join(inputpath,'sigma_'+str(ispin)+'.dat'),'w')
-                    for n in xrange(ene.size):
+                    for n in range(ene.size):
                         f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                             %(ene[n],L0[0,0,n],L0[1,1,n],L0[2,2,n],L0[0,1,n],L0[0,2,n],L0[1,2,n]))
                     f.close()
@@ -1411,7 +1411,7 @@
                     L1 *= (ELECTRONVOLT_SI**2/(4.0*np.pi**3))*(ELECTRONVOLT_SI**2/(H_OVER_TPI**2*BOHR_RADIUS_SI))
     
                     if rank == 0:
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             try:
                                 S[:,:,n] = LAN.inv(L0[:,:,n])*L1[:,:,n]*(-K_BOLTZMAN_SI/(temp*ELECTRONVOLT_SI**2))*1.e4
                             except:
@@ -1419,7 +1419,7 @@
                                 raise ValueError
     
                         f=open(os.path.join(inputpath,'Seebeck_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                                     %(ene[n],S[0,0,n],S[1,1,n],S[2,2,n],S[0,1,n],S[0,2,n],S[1,2,n]))
                         f.close()
@@ -1433,11 +1433,11 @@
                     L2 *= (ELECTRONVOLT_SI**2/(4.0*np.pi**3))*(ELECTRONVOLT_SI**3/(H_OVER_TPI**2*BOHR_RADIUS_SI))
     
                     if rank == 0:
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             kappa[:,:,n] = (L2[:,:,n] - L1[:,:,n]*LAN.inv(L0[:,:,n])*L1[:,:,n])*(K_BOLTZMAN_SI/(temp*ELECTRONVOLT_SI**3))*1.e-15
     
                         f=open(os.path.join(inputpath,'kappa_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e %9.5e %9.5e %9.5e %9.5e %9.5e \n' \
                                     %(ene[n],kappa[0,0,n],kappa[1,1,n],kappa[2,2,n],kappa[0,1,n],kappa[0,2,n],kappa[1,2,n]))
                         f.close()
@@ -1471,25 +1471,25 @@
     
             omega = alat**3 * np.dot(a_vectors[0,:],np.cross(a_vectors[1,:],a_vectors[2,:]))
     
-            for n in xrange(d_tensor.shape[0]):
+            for n in range(d_tensor.shape[0]):
                 ipol = d_tensor[n][0]
                 jpol = d_tensor[n][1]
-                for ispin in xrange(nspin):
+                for ispin in range(nspin):
                     ene, epsi, epsr, jdos = do_epsilon(E_k,pksp,kq_wght,omega,shift,delta,temp,ipol,jpol,ispin,metal,ne,epsmin,epsmax,deltakp,deltakp2,smearing,kramerskronig)
     
                     if rank == 0:
                         f=open(os.path.join(inputpath,'epsi_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],epsi[ipol,jpol,n]))
                         f.close()
                         f=open(os.path.join(inputpath,'epsr_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],epsr[ipol,jpol,n]))
                         f.close()
                         f=open(os.path.join(inputpath,'jdos_'+str(ispin)+'.dat'),'w')
-                        for n in xrange(ene.size):
+                        for n in range(ene.size):
                             f.write('%.5f %9.5e \n' \
                                     %(ene[n],jdos[n]))
                         f.close()
--- PAOFLOW/src/defs/add_ext_field.py	(original)
+++ PAOFLOW/src/defs/add_ext_field.py	(refactored)
@@ -29,7 +29,7 @@
 
     if Efield.any() != 0.0:
         # Electric field
-        for n in xrange(nawf):
+        for n in range(nawf):
             HRs[n,n,0,:] -= Efield.dot(tau_wf[n,:])
 
     if Bfield.any() != 0.0:
@@ -43,7 +43,7 @@
     #            HRs[n,m,i,:] *= np.exp(-np.pi*arg*1.j)
 
     if HubbardU.any() != 0:
-        for n in xrange(nawf):
+        for n in range(nawf):
             HRs[n,n,0,:] -= HubbardU[n]/2.0
 
     HRs = np.reshape(HRs,(nawf,nawf,nk1,nk2,nk3,nspin),order='C')
--- PAOFLOW/src/defs/build_Hks.py	(original)
+++ PAOFLOW/src/defs/build_Hks.py	(refactored)
@@ -22,8 +22,8 @@
         Hks = np.zeros((bnd,bnd,nkpnts,nspin),dtype=complex)
     else:
         Hks = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ik in xrange(nkpnts):
-        for ispin in xrange(nspin):
+    for ik in range(nkpnts):
+        for ispin in range(nspin):
             my_eigs=my_eigsmat[:,ik,ispin]
             #Building the Hamiltonian matrix
             E = np.diag(my_eigs)
@@ -32,7 +32,7 @@
             UU[:,:nawf] = UU[:,:nawf]*norms[:nawf]
             # Choose only the eigenvalues that are below the energy shift
             bnd_ik=0
-            for n in xrange(bnd):
+            for n in range(bnd):
                 if my_eigs[n] <= eta:
                     bnd_ik += 1
             if bnd_ik == 0: sys.exit('no eigenvalues in selected energy range')
--- PAOFLOW/src/defs/build_Pn.py	(original)
+++ PAOFLOW/src/defs/build_Pn.py	(refactored)
@@ -13,8 +13,8 @@
 
 def build_Pn(nawf,nbnds,nkpnts,nspin,U):
     Pn = 0.0
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             UU = np.transpose(U[:,:,ik,ispin]) #transpose of U. Now the columns of UU are the eigenvector of length nawf
             Pn += np.real(np.sum(np.conj(UU)*UU,axis=0))/nkpnts/nspin
     return Pn
--- PAOFLOW/src/defs/calc_PAO_eigs_vecs.py	(original)
+++ PAOFLOW/src/defs/calc_PAO_eigs_vecs.py	(refactored)
@@ -40,7 +40,7 @@
 
 
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         E_kaux[:,:,ispin], v_kaux[:,:,:,ispin] = diago(aux.shape[0],aux[:,:,:,ispin])
 
     aux = None
@@ -52,7 +52,7 @@
     ekp = np.zeros((nsize,nawf),dtype=float)
     ekv = np.zeros((nsize,nawf,nawf),dtype=complex)
 
-    for n in xrange(nsize):
+    for n in range(nsize):
         eigval,eigvec = LAN.eigh(aux[n,:,:],UPLO='U')
         ekp[n,:] = np.real(eigval)
         ekv[n,:,:] = eigvec
--- PAOFLOW/src/defs/clebsch_gordan.py	(original)
+++ PAOFLOW/src/defs/clebsch_gordan.py	(refactored)
@@ -62,7 +62,7 @@
         Ul1[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul1[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul1[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -80,7 +80,7 @@
         Ul2[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul2[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul2[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -98,7 +98,7 @@
         Ul3[m1-1,2*(m1-1)+1-1] = spinor(l,j,m,0)
         Ul3[m1-1,2*(m1-1)+4-1] = spinor(l,j,m,1)
     j = l + 0.5
-    for m1 in xrange (1,2*l+2+1):
+    for m1 in range (1,2*l+2+1):
         m = m1 - l - 2
         if (m1 == 1):
            Ul3[m1+2*l-1,2*(m1-1)+2-1] = spinor(l,j,m,1)
@@ -118,14 +118,14 @@
     nl = np.asarray(nl)
 
     ntot = 0
-    for n in xrange(len(sh)):
+    for n in range(len(sh)):
         ntot += nl[n]*occ[sh[n]]
     if ntot != nawf: sys.exit('wrong number of shells in reading')
     Tn = np.zeros((ntot,ntot),dtype=float)
 
     n = 0
-    for l in xrange(len(sh)):
-        for i in xrange(nl[l]):
+    for l in range(len(sh)):
+        for i in range(nl[l]):
             Tn[n:n+occ[sh[l]],n:n+occ[sh[l]]] = Ul[sh[l]]
             n += occ[sh[l]]
 
@@ -134,7 +134,7 @@
 
     # Spin operator matrix  in the basis of |l,m,s,s_z>
     Sl = np.zeros((nawf,nawf),dtype=complex)
-    for i in xrange(0,nawf,2):
+    for i in range(0,nawf,2):
         Sl[i,i] = sP[spol][0,0]
         Sl[i,i+1] = sP[spol][0,1]
         Sl[i+1,i] = sP[spol][1,0]
--- PAOFLOW/src/defs/communication.py	(original)
+++ PAOFLOW/src/defs/communication.py	(refactored)
@@ -110,7 +110,7 @@
     nchunks = nsize/size
     
     if nchunks!=0:
-        for pool in xrange(npool):
+        for pool in range(npool):
             chunk_s,chunk_e = load_balancing(npool,pool,nchunks)
 
             if rank==sroot:
@@ -150,7 +150,7 @@
     nchunks = nsize/size
     
     if nchunks!=0:
-        for pool in xrange(npool):
+        for pool in range(npool):
             chunk_s,chunk_e = load_balancing(npool,pool,nchunks)
 
             if rank==sroot:
@@ -172,7 +172,7 @@
 
 def gather_scatter(arr,scatter_axis,npool):
     #scatter indices for scatter_axis to each proc
-    axis_ind = np.array(xrange(arr.shape[scatter_axis]),dtype=int)
+    axis_ind = np.array(range(arr.shape[scatter_axis]),dtype=int)
     axis_ind = scatter_full(axis_ind,npool)
 
     #broadcast indices that for scattered array to proc with rank 'r'
@@ -195,7 +195,7 @@
     start = end - size_r
     size_r = None
     
-    for r in xrange(size):
+    for r in range(size):
         comm.Barrier()
         #gather array from each proc with indices for each proc on scatter_axis
         if r==rank:
--- PAOFLOW/src/defs/do_Berry_conductivity.py	(original)
+++ PAOFLOW/src/defs/do_Berry_conductivity.py	(refactored)
@@ -79,13 +79,13 @@
 
 
     # Collapsing the sum over k points
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m != n:
                 E_diff_nm[:,n,m] = (E_k[:,n,ispin]-E_k[:,m,ispin])**2
                 f_nm[:,n,m]      = (fn[:,n] - fn[:,m])*np.imag(pksp[:,jpol,n,m,0]*pksp[:,ipol,m,n,0])
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing!=None:
             sigxy[e] = np.sum(1.0/(E_diff_nm[:,:,:]-(ene[e]+1.0j*deltak2[:,:,:,ispin])**2+eps)*f_nm[:,:,:])
         else:
--- PAOFLOW/src/defs/do_Berry_curvature.py	(original)
+++ PAOFLOW/src/defs/do_Berry_curvature.py	(refactored)
@@ -43,8 +43,8 @@
 
     deltap = 0.05
 
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m!= n:
                 Om_znk[:,n] += -2.0*np.imag(pksp[:,ipol,n,m,0]*pksp[:,jpol,m,n,0]) / \
                 ((E_k[:,m,0] - E_k[:,n,0])**2 + deltap**2)
@@ -54,7 +54,7 @@
 
     Om_zkaux = np.zeros((pksp.shape[0],ene.size),dtype=float)
 
-    for i in xrange(ene.size):
+    for i in range(ene.size):
         if smearing == 'gauss':
             Om_zkaux[:,i] = np.sum(Om_znk[:,:]*intgaussian(E_k[:,:,0],ene[i],deltak[:,:,0]),axis=1)
         elif smearing == 'm-p':
@@ -83,7 +83,7 @@
 
     n0 = 0
     if rank == 0:
-        for i in xrange(ene.size-1):
+        for i in range(ene.size-1):
             if ene[i] <= fermi_dw and ene[i+1] >= fermi_dw:
                 n0 = i
             if ene[i] <= fermi_up and ene[i+1] >= fermi_up:
--- PAOFLOW/src/defs/do_Boltz_tensors.py	(original)
+++ PAOFLOW/src/defs/do_Boltz_tensors.py	(refactored)
@@ -85,9 +85,9 @@
 
 
     if smearing == None:
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             Eaux = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T - ene
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 if smearing == None:
@@ -97,10 +97,10 @@
 
     if smearing == 'gauss':
         om = ((ene*np.ones((E_k.shape[0],ene.size),dtype=float)).T).T
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             eig = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
             delk = (deltak[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 L[i,j,:] += np.sum((kq_wght[0]*velkp[:,i,n,ispin]*velkp[:,j,n,ispin] * \
@@ -109,10 +109,10 @@
 
     if smearing == 'm-p': 
         om = ((ene*np.ones((E_k.shape[0],ene.size),dtype=float)).T).T
-        for n in xrange(velkp.shape[2]):
+        for n in range(velkp.shape[2]):
             eig = (E_k[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
             delk = (deltak[:,n,ispin]*np.ones((E_k.shape[0],ene.size),dtype=float).T).T
-            for l in xrange(t_tensor.shape[0]):
+            for l in range(t_tensor.shape[0]):
                 i = t_tensor[l][0]
                 j = t_tensor[l][1]
                 L[i,j,:] += np.sum((kq_wght[0]*velkp[:,i,n,ispin]*velkp[:,j,n,ispin] * \
--- PAOFLOW/src/defs/do_adaptive_smearing.py	(original)
+++ PAOFLOW/src/defs/do_adaptive_smearing.py	(refactored)
@@ -47,9 +47,9 @@
     deltakp2 = np.zeros((pksp.shape[0],nawf,nawf,nspin),dtype=float)
 
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         deltakp[:,n] = LAN.norm(np.real(pksaux[:,:,n]),axis=1)
-        for m in xrange(nawf):
+        for m in range(nawf):
             deltakp2[:,n,m,:] = LAN.norm(pksaux[:,:,n,:] - pksaux[:,:,m,:],axis=1)
 
     pksaux=None
--- PAOFLOW/src/defs/do_bands_calc.py	(original)
+++ PAOFLOW/src/defs/do_bands_calc.py	(refactored)
@@ -54,8 +54,8 @@
     E_kp_aux = np.zeros((kq_aux.shape[1],nawf,nspin),dtype=float,order="C")
     v_kp_aux = np.zeros((kq_aux.shape[1],nawf,nawf,nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
-        for ik in xrange(kq_aux.shape[1]):
+    for ispin in range(nspin):
+        for ik in range(kq_aux.shape[1]):
             if read_S:
                 E_kp_aux[ik,:,ispin],v_kp_aux[ik,:,:,ispin] = LAN.eigh(Hks_aux[:,:,ik,ispin], 
                                                                        b=Sks_aux[:,:,ik],lower=False, 
@@ -83,9 +83,9 @@
     comm.Barrier()
   
     if rank==0:
-        for ispin in xrange(nspin):
+        for ispin in range(nspin):
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(kq.shape[1]):
+            for ik in range(kq.shape[1]):
                 s="%d\t"%ik
                 for  j in E_kp[ik,:,ispin]:s += "% 3.5f\t"%j
                 s+="\n"
@@ -105,7 +105,7 @@
 
     auxh = np.zeros((nawf,nawf,kq.shape[1],nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         auxh[:,:,:,ispin]=np.tensordot(HRaux[:,:,:,ispin],kdot,axes=([2],[0]))
 
     kdot  = None
@@ -117,10 +117,10 @@
     nsize = kq.shape[1]
     auxs  = np.zeros((nawf,nawf,nsize),dtype=complex)
 
-    for ik in xrange(kq.shape[1]):
-        for i in xrange(nk1):
-            for j in xrange(nk2):
-                for k in xrange(nk3):
+    for ik in range(kq.shape[1]):
+        for i in range(nk1):
+            for j in range(nk2):
+                for k in range(nk3):
                     phase=R_wght[idx[i,j,k]]*cmath.exp(2.0*np.pi*kq[:,ik].dot(R[idx[i,j,k],:])*1j)
                     auxs[:,:,ik] += SRaux[:,:,i,j,k]*phase
 
--- PAOFLOW/src/defs/do_bands_calc_1D.py	(original)
+++ PAOFLOW/src/defs/do_bands_calc_1D.py	(refactored)
@@ -29,19 +29,19 @@
 
     # Count points along symmetry direction
     nL = 0
-    for ik1 in xrange(nk1):
-        for ik2 in xrange(nk2):
-            for ik3 in xrange(nk3):
+    for ik1 in range(nk1):
+        for ik2 in range(nk2):
+            for ik3 in range(nk3):
                 nL += 1
 
     Hkaux  = np.zeros((nawf,nawf,nL,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 nL=0
-                for ik1 in xrange(nk1):
-                    for ik2 in xrange(nk2):
-                        for ik3 in xrange(nk3):
+                for ik1 in range(nk1):
+                    for ik2 in range(nk2):
+                        for ik3 in range(nk3):
                             Hkaux[i,j,nL,ispin]=Hksp[i,j,ik1,ik2,ik3,ispin]
                             nL += 1
 
@@ -49,24 +49,24 @@
     # k to R
     npad = 500
     HRaux  = np.zeros((nawf,nawf,nL,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 HRaux[i,j,:,ispin] = FFT.ifft(Hkaux[i,j,:,ispin])
 
     Hkaux = None
     Hkaux  = np.zeros((nawf,nawf,npad+nL,nspin),dtype=complex)
     HRauxp  = np.zeros((nawf,nawf,npad+nL,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
-        for i in xrange(nawf):
-            for j in xrange(nawf):
+    for ispin in range(nspin):
+        for i in range(nawf):
+            for j in range(nawf):
                 HRauxp[i,j,:(nL/2),ispin]=HRaux[i,j,:(nL/2),ispin]
                 HRauxp[i,j,(npad+nL/2):,ispin]=HRaux[i,j,(nL/2):,ispin]
                 Hkaux[i,j,:,ispin] = FFT.fft(HRauxp[i,j,:,ispin])
 
     # Print PAO eigenvalues on interpolated mesh
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         write_PAO_eigs(Hkaux,ispin,inputpath)
 
     return()
--- PAOFLOW/src/defs/do_dos_calc.py	(original)
+++ PAOFLOW/src/defs/do_dos_calc.py	(refactored)
@@ -41,7 +41,7 @@
 
     dosaux=np.zeros((ene.size),order="C")
 
-    for ne in xrange(ene.size):
+    for ne in range(ene.size):
         dosaux[ne] = np.sum(np.exp(-((ene[ne]-eig)/delta)**2))
 
     comm.Barrier()
@@ -52,7 +52,7 @@
     if rank == 0:
         dos *= float(nawf)/float(netot)*1.0/np.sqrt(np.pi)/delta
         f=open(os.path.join(inputpath,'dos_'+str(ispin)+'.dat'),'w')
-        for ne in xrange(ene.size):
+        for ne in range(ene.size):
             f.write('%.5f  %.5f \n' %(ene[ne],dos[ne]))
         f.close()
 
--- PAOFLOW/src/defs/do_dos_calc_adaptive.py	(original)
+++ PAOFLOW/src/defs/do_dos_calc_adaptive.py	(refactored)
@@ -37,7 +37,7 @@
     dos = np.zeros((ene.size),dtype=float)
     dosaux = np.zeros((ene.size),dtype=float)
 
-    for ne in xrange(ene.size):
+    for ne in range(ene.size):
         if smearing == 'gauss':
             # adaptive Gaussian smearing
             dosaux[ne] = np.sum(gaussian(ene[ne],eig,delta))
@@ -52,7 +52,7 @@
     if rank == 0:
         dos *= float(nawf)/float(netot)
         f=open(os.path.join(inputpath,'dosdk_'+str(ispin)+'.dat'),'w')
-        for ne in xrange(ene.size):
+        for ne in range(ene.size):
             f.write('%.5f  %.5f \n' %(ene[ne],dos[ne]))
         f.close()
 
--- PAOFLOW/src/defs/do_double_grid.py	(original)
+++ PAOFLOW/src/defs/do_double_grid.py	(refactored)
@@ -72,16 +72,16 @@
 
     Hk_aux  = np.zeros((HR_aux.shape[0],nk1p,nk2p,nk3p,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         if not scipyfft:
-            for i in xrange(nawf):
-                for j in xrange(nawf):
+            for i in range(nawf):
+                for j in range(nawf):
                     aux = zero_pad(H_aux[i,j,:,:,:,ispin],nk1,nk2,nk3,nfft1,nfft2,nfft3)
                     fft = pyfftw.FFTW(aux,Hksp[:,:,:,i,j,ispin], axes=(0,1,2), direction='FFTW_FORWARD',\
                         flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                     Hk_aux[:,:,:,i,j,ispin] = fft()
         else:
-            for n in xrange(HR_aux.shape[0]):
+            for n in range(HR_aux.shape[0]):
                 Hk_aux[n,:,:,:,ispin] = FFT.fftn(zero_pad(HR_aux[n,:,:,:,ispin],
                                                           nk1,nk2,nk3,nfft1,nfft2,nfft3))
 
--- PAOFLOW/src/defs/do_eigh_calc.py	(original)
+++ PAOFLOW/src/defs/do_eigh_calc.py	(refactored)
@@ -47,7 +47,7 @@
     E_kp = np.zeros((nkpi,nawf,nspin),dtype=float)
     v_kp = np.zeros((nkpi,nawf,nawf,nspin),dtype=complex)
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         for ik in range(nkpi):
             if read_S:
                 E_kp[ik,:,ispin],v_kp[ik,:,:,ispin] = LA.eigh(Hks_int[:,:,ik,ispin],Sks_int[:,:,ik])
@@ -69,8 +69,8 @@
     auxh = np.zeros((nawf,nawf,nkpi,nspin),dtype=complex)
     HRaux = np.reshape(HRaux,(nawf,nawf,nk1*nk2*nk3,nspin),order='C')
 
-    for ik in xrange(nkpi):
-        for ispin in xrange(nspin):
+    for ik in range(nkpi):
+        for ispin in range(nspin):
              auxh[:,:,ik,ispin] = np.sum(HRaux[:,:,:,ispin]*np.exp(2.0*np.pi*kq[ik,:].dot(R[:,:].T)*1j),axis=2)
 
     return(auxh)
@@ -79,10 +79,10 @@
 
     auxs = np.zeros((nawf,nawf,nkpi),dtype=complex)
 
-    for ik in xrange(nkpi):
-        for i in xrange(nk1):
-            for j in xrange(nk2):
-                for k in xrange(nk3):
+    for ik in range(nkpi):
+        for i in range(nk1):
+            for j in range(nk2):
+                for k in range(nk3):
                     phase=R_wght[idx[i,j,k]]*cmath.exp(2.0*np.pi*kq[ik,:].dot(R[idx[i,j,k],:])*1j)
                     auxs[:,:,ik] += SRaux[:,:,i,j,k]*phase
 
--- PAOFLOW/src/defs/do_epsilon.py	(original)
+++ PAOFLOW/src/defs/do_epsilon.py	(refactored)
@@ -101,9 +101,9 @@
     eps=1.e-8
     fnF = np.zeros((pksp.shape[0]),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
                 np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((pksp.shape[0],ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -114,7 +114,7 @@
                            kq_wght[0] /delta * dfunc * ((fn - fm)*np.ones((pksp.shape[0],ene.size),dtype=float).T).T).T* \
                            1.0),axis=1)
             if metal and n == m:
-                for ik in xrange(pksp.shape[0]):
+                for ik in range(pksp.shape[0]):
                     try:
                         fnF[ik] = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[ik,n,ispin]/temp))
                     except:
@@ -137,7 +137,7 @@
     effterm = np.zeros((pksp.shape[0],nawf),dtype=complex)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -146,7 +146,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -213,7 +213,7 @@
     # gaussian smearing
 
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing=='gauss':
             np.exp(-((ene[e]-E_diff_nm)/dk2_nm)**2,out=dfunc)
             dfunc *= sq2_dk2
@@ -244,7 +244,7 @@
 
 
 
-        for e in xrange(ene.size):
+        for e in range(ene.size):
             if smearing=='gauss':
                 np.exp(-((ene[e])/dk_cont)**2,out=dfunc)
                 dfunc *= sq2_dk1
@@ -273,7 +273,7 @@
     if ini_ie < 3: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
     f_ene = intmetpax(ene,shift,1.0)
-    for ie in xrange(ini_ie,end_ie):
+    for ie in range(ini_ie,end_ie):
         #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
         #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
         epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]*f_ene[1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_epsilon_d2.py	(original)
+++ PAOFLOW/src/defs/do_epsilon_d2.py	(refactored)
@@ -116,13 +116,13 @@
 
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
         try:
             fnF = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[:,n,ispin]/temp))
         except:
             fnF = 1.0e8*np.ones(end_ik-ini_ik,dtype=float)
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
                 np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((end_ik-ini_ik,ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -149,7 +149,7 @@
     effterm = np.zeros((end_ik-ini_ik,nawf),dtype=complex)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -158,7 +158,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -182,7 +182,7 @@
                                (pksp[:,ipol,n,m,ispin] * pksp[:,jpol,m,n,ispin]),axis=1))
     if metal:
         sum_rule = 0.0
-        for n in xrange(nawf):
+        for n in range(nawf):
             if smearing == 'gauss':
                 fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             elif smearing == 'm-p':
@@ -211,7 +211,7 @@
     Ef = 0.0
     deltat = 0.1
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             if metal: fnF = gaussian(E_k[:,n,ispin],Ef,0.03*deltak[:,n,ispin])
@@ -220,7 +220,7 @@
             if metal: fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,m,ispin])
             elif smearing == 'm-p':
@@ -269,7 +269,7 @@
     if ini_ie == 0: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
     f_ene = intmetpax(ene,shift,1.0)
-    for ie in xrange(ini_ie,end_ie):
+    for ie in range(ini_ie,end_ie):
         #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
         #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
         epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]*f_ene[1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_epsilon_old.py	(original)
+++ PAOFLOW/src/defs/do_epsilon_old.py	(refactored)
@@ -96,10 +96,10 @@
 
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         fn = 1.0/(np.exp(E_k[:,n,ispin]/temp)+1)
         fnF = 1.0/2.0 * 1.0/(1.0+np.cosh(E_k[:,n,ispin]/temp))
-        for m in xrange(nawf):
+        for m in range(nawf):
             fm = 1.0/(np.exp(E_k[:,m,ispin]/temp)+1)
             dfunc[:,:] = 1.0/np.sqrt(np.pi)* \
             np.exp(-((((E_k[:,n,ispin]-E_k[:,m,ispin])*np.ones((end_ik-ini_ik,ene.size),dtype=float).T).T + ene)/delta)**2)
@@ -122,7 +122,7 @@
     dfunc = np.zeros((end_ik-ini_ik,ene.size),dtype=float)
     Ef = 0.0
 
-    for n in xrange(nawf):
+    for n in range(nawf):
         if smearing == 'gauss':
             fn = intgaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
             fnF = gaussian(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
@@ -131,7 +131,7 @@
             fnF = metpax(E_k[:,n,ispin],Ef,deltak[:,n,ispin])
         else:
             sys.exit('smearing not implemented')
-        for m in xrange(nawf):
+        for m in range(nawf):
             if smearing == 'gauss':
                 fm = intgaussian(E_k[:,m,ispin],Ef,deltak[:,n,ispin])
             elif smearing == 'm-p':
@@ -181,9 +181,9 @@
 
     if ini_ie == 0: ini_ie = 3
     if end_ie == ene.size: end_ie = ene.size-1
-    for ie in xrange(ini_ie,end_ie):
-        for i in xrange(3):
-            for j in xrange(3):
+    for ie in range(ini_ie,end_ie):
+        for i in range(3):
+            for j in range(3):
                 #epsr[i,j,ie] = 2.0/np.pi * ( np.sum(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
                 #               np.sum(ene[(ie+1):ene.size]*de*epsi[i,j,(ie+1):ene.size]/(ene[(ie+1):ene.size]**2-ene[ie]**2)) )
                 epsr[i,j,ie] = 2.0/np.pi * ( tgr.simps(ene[1:(ie-1)]*de*epsi[i,j,1:(ie-1)]/(ene[1:(ie-1)]**2-ene[ie]**2)) + \
--- PAOFLOW/src/defs/do_fermisurf.py	(original)
+++ PAOFLOW/src/defs/do_fermisurf.py	(refactored)
@@ -58,7 +58,7 @@
 
         write2bxsf(fermi_dw,fermi_up,eigband, nk1, nk2, nk3, icount, ind_plot, Efermi, alat,x0, b_vectors, 'FermiSurf_'+str(ispin)+'.bxsf',inputpath)   
 
-        for ib in xrange(icount):
+        for ib in range(icount):
             np.savez(os.path.join(inputpath,'Fermi_surf_band_'+str(ib)), nameband = eigband[:,:,:,ib])
 
 
--- PAOFLOW/src/defs/do_gradient.py	(original)
+++ PAOFLOW/src/defs/do_gradient.py	(refactored)
@@ -69,19 +69,19 @@
     ### real space grid replaces k space ###
     ########################################
     if using_cuda:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 Hksp[n,:,:,:,ispin] = cuda_ifftn(Hksp[n,:,:,:,ispin])
 
     elif scipyfft:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 Hksp[n,:,:,:,ispin] = FFT.ifftn(Hksp[n,:,:,:,ispin],axes=(0,1,2))
                 Hksp[n,:,:,:,ispin] = FFT.fftshift(Hksp[n,:,:,:,ispin],axes=(0,1,2))
 
     else:
-        for n in xrange(Hksp.shape[0]):
-            for ispin in xrange(Hksp.shape[4]):
+        for n in range(Hksp.shape[0]):
+            for ispin in range(Hksp.shape[4]):
                 fft = pyfftw.FFTW(Hksp[n,:,:,:,ispin],Hksp[n,:,:,:,ispin],axes=(0,1,2),
                                   direction='FFTW_BACKWARD',flags=('FFTW_MEASURE', ),
                                   threads=nthread, planning_timelimit=None )
@@ -100,8 +100,8 @@
     dHksp = np.zeros((num_n,nk1*nk2*nk3,3,nspin),dtype=complex,order='C')
 
     # Compute R*H(R)
-    for ispin in xrange(nspin):
-        for l in xrange(3):
+    for ispin in range(nspin):
+        for l in range(3):
             dHksp[:,:,l,ispin] = 1.0j*alat*Rfft[:,l]*Hksp[...,ispin]
 
     Hksp=None
@@ -110,15 +110,15 @@
     # Compute dH(k)/dk
 
     if scipyfft:
-        for n in xrange(dHksp.shape[0]):
-            for l in xrange(dHksp.shape[4]):
-                for ispin in xrange(dHksp.shape[5]):
+        for n in range(dHksp.shape[0]):
+            for l in range(dHksp.shape[4]):
+                for ispin in range(dHksp.shape[5]):
                     dHksp[n,:,:,:,l,ispin] = FFT.fftn(dHksp[n,:,:,:,l,ispin],axes=(0,1,2),)
 
     else:
-        for n in xrange(dHksp.shape[0]):
-            for l in xrange(dHksp.shape[4]):
-                for ispin in xrange(dHksp.shape[5]):
+        for n in range(dHksp.shape[0]):
+            for l in range(dHksp.shape[4]):
+                for ispin in range(dHksp.shape[5]):
                     fft = pyfftw.FFTW(dHksp[n,:,:,:,l,ispin]
                                       ,dHksp[n,:,:,:,l,ispin],axes=(0,1,2),
                                       direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ),
--- PAOFLOW/src/defs/do_gradient_d2.py	(original)
+++ PAOFLOW/src/defs/do_gradient_d2.py	(refactored)
@@ -59,9 +59,9 @@
             Hksp = None
         else:
             HRaux  = np.zeros_like(Hksp)
-            for ispin in xrange(nspin):
-                for n in xrange(nawf):
-                    for m in xrange(nawf):
+            for ispin in range(nspin):
+                for n in range(nawf):
+                    for m in range(nawf):
                         fft = pyfftw.FFTW(Hksp[:,:,:,n,m,ispin],HRaux[:,:,:,n,m,ispin],axes=(0,1,2), direction='FFTW_BACKWARD',\
                               flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                         HRaux[:,:,:,n,m,ispin] = fft()
@@ -81,7 +81,7 @@
         dHRaux  = None
         d2HRaux  = None
 
-    for pool in xrange(npool):
+    for pool in range(npool):
         ini_ip, end_ip = load_balancing(npool,pool,nktot)
         nkpool = end_ip - ini_ip
 
@@ -102,12 +102,12 @@
         Rfftaux = scatter_array(Rfft_split)
 
         # Compute R*H(R)
-        for l in xrange(3):
-            for ispin in xrange(nspin):
-                for n in xrange(nawf):
-                    for m in xrange(nawf):
+        for l in range(3):
+            for ispin in range(nspin):
+                for n in range(nawf):
+                    for m in range(nawf):
                         dHRaux1[:,l,n,m,ispin] = 1.0j*alat*Rfftaux[:,l]*HRaux1[:,n,m,ispin]
-                        for lp in xrange(3):
+                        for lp in range(3):
                             d2HRaux1[:,l,lp,n,m,ispin] = -1.0*alat**2*Rfftaux[:,l]*Rfftaux[:,lp]*HRaux1[:,n,m,ispin]
 
         gather_array(dHRaux_split, dHRaux1)
@@ -126,20 +126,20 @@
         if scipyfft:
             dHksp  = np.zeros((nk1,nk2,nk3,3,nawf,nawf,nspin),dtype=complex)
             d2Hksp  = np.zeros((nk1,nk2,nk3,3,3,nawf,nawf,nspin),dtype=complex)
-            for l in xrange(3):
+            for l in range(3):
                 dHksp[:,:,:,l,:,:,:] = FFT.fftn(dHRaux[:,:,:,l,:,:,:],axes=[0,1,2])
-                for lp in xrange(3):
+                for lp in range(3):
                     d2Hksp[:,:,:,l,lp,:,:,:] = FFT.fftn(d2HRaux[:,:,:,l,lp,:,:,:],axes=[0,1,2])
             dHraux = None
         else:
-            for l in xrange(3):
-                for ispin in xrange(nspin):
-                    for n in xrange(nawf):
-                        for m in xrange(nawf):
+            for l in range(3):
+                for ispin in range(nspin):
+                    for n in range(nawf):
+                        for m in range(nawf):
                             fft = pyfftw.FFTW(dHRaux[:,:,:,l,n,m,ispin],dHksp[:,:,:,l,n,m,ispin],axes=(0,1,2), \
                             direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                             dHksp[:,:,:,l,n,m,ispin] = fft()
-                            for lp in xrange(3):
+                            for lp in range(3):
                                 fft = pyfftw.FFTW(d2HRaux[:,:,:,l,lp,n,m,ispin],d2Hksp[:,:,:,l,lp,n,m,ispin],axes=(0,1,2), \
                                 direction='FFTW_FORWARD',flags=('FFTW_MEASURE', ), threads=nthread, planning_timelimit=None )
                                 d2Hksp[:,:,:,l,lp,n,m,ispin] = fft()
--- PAOFLOW/src/defs/do_momentum.py	(original)
+++ PAOFLOW/src/defs/do_momentum.py	(refactored)
@@ -35,17 +35,17 @@
 
 
 
-    for ik in xrange(dHksp.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(dHksp.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 pksp[ik,l,:,:,ispin] = dHksp[ik,l,:,:,ispin].dot(vec[ik,:,:,ispin])
 
 
     vec_cross = np.ascontiguousarray(np.conj(np.swapaxes(vec,1,2)))
 
-    for ik in xrange(dHksp.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(dHksp.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 pksp[ik,l,:,:,ispin] = vec_cross[ik,:,:,ispin].dot(pksp[ik,l,:,:,ispin])
 
     comm.Barrier()
--- PAOFLOW/src/defs/do_momentum_d2.py	(original)
+++ PAOFLOW/src/defs/do_momentum_d2.py	(refactored)
@@ -49,7 +49,7 @@
         pksp = None
         tksp = None
 
-    for pool in xrange(npool):
+    for pool in range(npool):
         ini_ip, end_ip = load_balancing(npool, pool, nktot)
         nkpool = end_ip - ini_ip 
 
@@ -72,12 +72,12 @@
         tksaux = scatter_array(tks_split)
         vecaux = scatter_array(vec_split)
 
-        for ik in xrange(nsize):
-            for ispin in xrange(nspin):
-                for l in xrange(3):
+        for ik in range(nsize):
+            for ispin in range(nspin):
+                for l in range(3):
                     pksaux[ik,l,:,:,ispin] = np.conj(vecaux[ik,:,:,ispin].T).dot \
                                 (dHkaux[ik,l,:,:,ispin]).dot(vecaux[ik,:,:,ispin])
-                    for lp in xrange(3):
+                    for lp in range(3):
                         tksaux[ik,l,lp,:,:,ispin] = np.conj(vecaux[ik,:,:,ispin].T).dot \
                                     (d2Hkaux[ik,l,lp,:,:,ispin]).dot(vecaux[ik,:,:,ispin])
 
--- PAOFLOW/src/defs/do_non_ortho.py	(original)
+++ PAOFLOW/src/defs/do_non_ortho.py	(refactored)
@@ -22,12 +22,12 @@
 
     nawf,_,nkpnts,nspin = Hks.shape
     S2k  = np.zeros((nawf,nawf,nkpnts),dtype=complex)
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         S2k[:,:,ik] = LA.sqrtm(Sks[:,:,ik])
 
     Hks_no = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             Hks_no[:,:,ik,ispin] = np.dot(S2k[:,:,ik],Hks[:,:,ik,ispin]).dot(S2k[:,:,ik])
 
     return(Hks_no)
--- PAOFLOW/src/defs/do_ortho.py	(original)
+++ PAOFLOW/src/defs/do_ortho.py	(refactored)
@@ -21,12 +21,12 @@
 
     nawf,_,nkpnts,nspin = Hks.shape
     S2k  = np.zeros((nawf,nawf,nkpnts),dtype=complex)
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         S2k[:,:,ik] = LAN.inv(LA.sqrtm(Sks[:,:,ik]))
 
     Hks_o = np.zeros((nawf,nawf,nkpnts,nspin),dtype=complex)
-    for ispin in xrange(nspin):
-        for ik in xrange(nkpnts):
+    for ispin in range(nspin):
+        for ik in range(nkpnts):
             Hks_o[:,:,ik,ispin] = np.dot(S2k[:,:,ik],Hks[:,:,ik,ispin]).dot(S2k[:,:,ik])
 
     return(Hks_o)
--- PAOFLOW/src/defs/do_spin_Berry_curvature.py	(original)
+++ PAOFLOW/src/defs/do_spin_Berry_curvature.py	(refactored)
@@ -46,8 +46,8 @@
 
 
     deltap = 0.05
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m!= n:
                 Om_znkaux[:,n] += -2.0*np.imag(jksp[:,ipol,n,m,0]*pksp[:,jpol,m,n,0]) / \
                 ((E_k[:,m,0] - E_k[:,n,0])**2 + deltap**2)
@@ -64,7 +64,7 @@
 
     Om_zkaux = np.zeros((pksp.shape[0],ene.size),dtype=float)
 
-    for i in xrange(ene.size):
+    for i in range(ene.size):
         if smearing == 'gauss':
             Om_zkaux[:,i] = np.sum(Om_znkaux[:,:]*intgaussian(E_k[:,:,0],ene[i],deltak[:,:,0]),axis=1)
         elif smearing == 'm-p':
@@ -86,7 +86,7 @@
     n0 = 0
     if rank == 0:
         Om_k = np.zeros((nk1,nk2,nk3,ene.size),dtype=float)
-        for i in xrange(ene.size-1):
+        for i in range(ene.size-1):
             if ene[i] <= fermi_dw and ene[i+1] >= fermi_dw:
                 n0 = i
             if ene[i] <= fermi_up and ene[i+1] >= fermi_up:
--- PAOFLOW/src/defs/do_spin_Hall_conductivity.py	(original)
+++ PAOFLOW/src/defs/do_spin_Hall_conductivity.py	(refactored)
@@ -79,15 +79,15 @@
         fn = intmetpax(E_k[:,:,0],Ef,deltak[:,:,0]) 
 
     # Collapsing the sum over k points
-    for n in xrange(nawf):
-        for m in xrange(nawf):
+    for n in range(nawf):
+        for m in range(nawf):
             if m != n:
                 E_diff_nm[:,n,m] = (E_k[:,n,ispin]-E_k[:,m,ispin])**2
                 f_nm[:,n,m]      = (fn[:,n] - fn[:,m])*np.imag(jksp[:,jpol,n,m,0]*pksp[:,ipol,m,n,0])
 
     fn = None
 
-    for e in xrange(ene.size):
+    for e in range(ene.size):
         if smearing!=None:
             sigxy[e] = np.sum(1.0/(E_diff_nm[:,:,:]-(ene[e]+1.0j*deltak2[:,:,:,ispin])**2+eps)*f_nm[:,:,:])
         else:
--- PAOFLOW/src/defs/do_spin_current.py	(original)
+++ PAOFLOW/src/defs/do_spin_current.py	(refactored)
@@ -38,10 +38,10 @@
     if spin_orbit:
         # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
         Sj = np.zeros((nawf,nawf),dtype=complex)
-        for i in xrange(nawf/2):
+        for i in range(nawf/2):
             Sj[i,i] = sP[spol][0,0]
             Sj[i,i+1] = sP[spol][0,1]
-        for i in xrange(nawf/2,nawf):
+        for i in range(nawf/2,nawf):
             Sj[i,i-1] = sP[spol][1,0]
             Sj[i,i] = sP[spol][1,1]
     else:
@@ -54,18 +54,18 @@
 
 
 
-    for ik in xrange(dHksp.shape[0]):
-        for l in xrange(3):
-            for ispin in xrange(nspin):
+    for ik in range(dHksp.shape[0]):
+        for l in range(3):
+            for ispin in range(nspin):
                 jdHksp[ik,l,:,:,ispin] = \
                     0.5*(np.dot(Sj,dHksp[ik,l,:,:,ispin])+np.dot(dHksp[ik,l,:,:,ispin],Sj))
                 
 
     jksp = np.zeros((dHksp.shape[0],3,bnd,bnd,nspin),dtype=complex)
 
-    for ik in xrange(dHksp.shape[0]):
-        for l in xrange(3):            
-            for ispin in xrange(nspin):
+    for ik in range(dHksp.shape[0]):
+        for l in range(3):            
+            for ispin in range(nspin):
 
                 jksp[ik,l,:,:,ispin] = np.conj(vec[ik,:,:,ispin].T).dot \
                             (jdHksp[ik,l,:,:,ispin]).dot(vec[ik,:,:,ispin])[:bnd,:bnd]
--- PAOFLOW/src/defs/do_spin_orbit.py	(original)
+++ PAOFLOW/src/defs/do_spin_orbit.py	(refactored)
@@ -43,7 +43,7 @@
 
     M=9
     nt=natoms
-    for n in xrange(nt):
+    for n in range(nt):
         i=n*M
         j=(n+1)*M
         # Up-Up
--- PAOFLOW/src/defs/do_spin_texture.py	(original)
+++ PAOFLOW/src/defs/do_spin_texture.py	(refactored)
@@ -55,17 +55,17 @@
     if spin_orbit:
         # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
         Sj = np.zeros((3,nawf,nawf),dtype=complex)
-        for spol in xrange(3):
-            for i in xrange(nawf/2):
+        for spol in range(3):
+            for i in range(nawf/2):
                 Sj[spol,i,i] = sP[spol][0,0]
                 Sj[spol,i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[spol,i,i-1] = sP[spol][1,0]
                 Sj[spol,i,i] = sP[spol][1,1]
     else:
         # Spin operator matrix  in the basis of |j,m_j,l,s> (full SO)
         Sj = np.zeros((3,nawf,nawf),dtype=complex)
-        for spol in xrange(3):
+        for spol in range(3):
             Sj[spol,:,:] = clebsch_gordan(nawf,sh,nl,spol)
 
     # Compute matrix elements of the spin operator
@@ -75,9 +75,9 @@
 
     sktxtaux = np.zeros((vec.shape[0],3,nawf,nawf),dtype=complex)
 
-    for ik in xrange(vec.shape[0]):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(vec.shape[0]):
+        for ispin in range(nspin):
+            for l in range(3):
                 sktxtaux[ik,l,:,:] = np.conj(vec[ik,:,:,ispin].T).dot \
                             (Sj[l,:,:]).dot(vec[ik,:,:,ispin])
 
@@ -87,7 +87,7 @@
     if rank == 0:
         sktxt = np.reshape(sktxt,(nk1,nk2,nk3,3,nawf,nawf),order='C')
 
-        for ib in xrange(icount):
+        for ib in range(icount):
             np.savez(os.path.join(inputpath,'spin_text_band_'+str(ib)), spinband = sktxt[:,:,:,:,ind_plot[ib],ind_plot[ib]])
 
     sktxt = None
--- PAOFLOW/src/defs/do_topology_calc.py	(original)
+++ PAOFLOW/src/defs/do_topology_calc.py	(refactored)
@@ -60,11 +60,11 @@
         # Define time reversal operator
         theta = -1.0j*clebsch_gordan(nawf,sh,nl,1)
         wl = np.zeros((nktrim/2,nawf,nawf),dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             wl[ik,:,:] = np.conj(v_ktrim[ik,:,:,0].T).dot(theta).dot(np.conj(v_ktrim[ik+nktrim/2,:,:,0]))
             wl[ik,:,:] = wl[ik,:,:]-wl[ik,:,:].T  # enforce skew symmetry
         delta_ik = np.zeros(nktrim/2,dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             delta_ik[ik] = pf.pfaffian(wl[ik,:nelec,:nelec])/np.sqrt(LAN.det(wl[ik,:nelec,:nelec]))
 
         f=open(inputpath+'Z2'+'.dat','w')
@@ -105,10 +105,10 @@
     Rfft = np.reshape(Rfft,(nk1*nk2*nk3,3),order='C')
     HRs = np.reshape(HRs,(nawf,nawf,nk1*nk2*nk3,nspin),order='C')
     dHRs  = np.zeros((3,nawf,nawf,nk1*nk2*nk3,nspin),dtype=complex)
-    for l in xrange(3):
-        for ispin in xrange(nspin):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+    for l in range(3):
+        for ispin in range(nspin):
+            for n in range(nawf):
+                for m in range(nawf):
                     dHRs[l,n,m,:,ispin] = 1.0j*alat*ANGSTROM_AU*Rfft[:,l]*HRs[n,m,:,ispin]
 
     # Compute dH(k)/dk on the path
@@ -132,9 +132,9 @@
 
     # Compute momenta
     pks = np.zeros((nkpi,3,nawf,nawf,nspin),dtype=complex)
-    for ik in xrange(nkpi):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(nkpi):
+        for ispin in range(nspin):
+            for l in range(3):
                 pks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                             (dHks[l,:,:,ik,ispin]).dot(v_kp[ik,:,:,ispin])
 
@@ -150,10 +150,10 @@
         if spin_orbit:
             # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
             Sj = np.zeros((nawf,nawf),dtype=complex)
-            for i in xrange(nawf/2):
+            for i in range(nawf/2):
                 Sj[i,i] = sP[spol][0,0]
                 Sj[i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[i,i-1] = sP[spol][1,0]
                 Sj[i,i] = sP[spol][1,1]
         else:
@@ -162,9 +162,9 @@
 
         #jdHks = np.zeros((3,nawf,nawf,nkpi,nspin),dtype=complex)
         jks = np.zeros((nkpi,3,nawf,nawf,nspin),dtype=complex)
-        for ik in xrange(nkpi):
-            for ispin in xrange(nspin):
-                for l in xrange(3):
+        for ik in range(nkpi):
+            for ispin in range(nspin):
+                for l in range(3):
                     jks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                                 (0.5*(np.dot(Sj,dHks[l,:,:,ik,ispin])+np.dot(dHks[l,:,:,ik,ispin],Sj))).dot(v_kp[ik,:,:,ispin])
 
@@ -177,9 +177,9 @@
         mu = -0.2 # chemical potential in eV)
         Om_znk = np.zeros((nkpi,nawf),dtype=float)
         Om_zk = np.zeros((nkpi),dtype=float)
-        for ik in xrange(nkpi):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+        for ik in range(nkpi):
+            for n in range(nawf):
+                for m in range(nawf):
                     if m!= n:
                         if Berry:
                             Om_znk[ik,n] += -1.0*np.imag(pks[ik,jpol,n,m,0]*pks[ik,ipol,m,n,0]-pks[ik,ipol,n,m,0]*pks[ik,jpol,m,n,0]) / \
@@ -193,24 +193,24 @@
     if rank == 0:
         if Berry:
             f=open(inputpath+'Omega_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat','w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,-Om_zk[ik]))
             f.close()
         if spin_Hall:
             f=open(inputpath+'Omegaj_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat','w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,Omj_zk[ik]))
             f.close()
 
     if rank == 0:
         if spin_orbit: bnd *= 2
         velk = np.zeros((nkpi,3,nawf,nspin),dtype=float)
-        for n in xrange(nawf):
+        for n in range(nawf):
             velk[:,:,n,:] = np.real(pks[:,:,n,n,:])
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+        for ispin in range(nspin):
+            for l in range(3):
                 f=open(inputpath+'velocity_'+str(l)+'_'+str(ispin)+'.dat','w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in velk[ik,l,:bnd,ispin]:s += "%3.5f\t"%j
                     s+="\n"
@@ -223,9 +223,9 @@
 
     auxh = np.zeros((3,nawf,nawf,nkpi,nspin),dtype=complex)
 
-    for ik in xrange(ini_ik,end_ik):
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+    for ik in range(ini_ik,end_ik):
+        for ispin in range(nspin):
+            for l in range(3):
                 auxh[l,:,:,ik,ispin] = np.sum(dHRaux[l,:,:,:,ispin]*np.exp(2.0*np.pi*kq[:,ik].dot(R[:,:].T)*1j),axis=2)
 
     return(auxh)
--- PAOFLOW/src/defs/do_topology_calc_new.py	(original)
+++ PAOFLOW/src/defs/do_topology_calc_new.py	(refactored)
@@ -60,11 +60,11 @@
         # Define time reversal operator
         theta = -1.0j*clebsch_gordan(nawf,sh,nl,1)
         wl = np.zeros((nktrim/2,nawf,nawf),dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             wl[ik,:,:] = np.conj(v_ktrim[ik,:,:,0].T).dot(theta).dot(np.conj(v_ktrim[ik+nktrim/2,:,:,0]))
             wl[ik,:,:] = wl[ik,:,:]-wl[ik,:,:].T  # enforce skew symmetry
         delta_ik = np.zeros(nktrim/2,dtype=complex)
-        for ik in xrange(nktrim/2):
+        for ik in range(nktrim/2):
             delta_ik[ik] = pf.pfaffian(wl[ik,:nelec,:nelec])/np.sqrt(LAN.det(wl[ik,:nelec,:nelec]))
 
         f=open(os.path.join(inputpath,'Z2'+'.dat'),'w')
@@ -123,10 +123,10 @@
         if spin_orbit:
             # Spin operator matrix  in the basis of |l,m,s,s_z> (TB SO)
             Sj = np.zeros((nawf,nawf),dtype=complex)
-            for i in xrange(nawf/2):
+            for i in range(nawf/2):
                 Sj[i,i] = sP[spol][0,0]
                 Sj[i,i+1] = sP[spol][0,1]
-            for i in xrange(nawf/2,nawf):
+            for i in range(nawf/2,nawf):
                 Sj[i,i-1] = sP[spol][1,0]
                 Sj[i,i] = sP[spol][1,1]
         else:
@@ -142,11 +142,11 @@
 
 
     pks = np.zeros((kq_aux.shape[1],3,bnd,bnd,nspin),dtype=complex)
-    for l in xrange(3):
+    for l in range(3):
         dHRs  = np.zeros((HRs_aux.shape[0],nawf,nawf,nspin),dtype=complex)
-        for ispin in xrange(nspin):
-            for n in xrange(nawf):
-                for m in xrange(nawf):
+        for ispin in range(nspin):
+            for n in range(nawf):
+                for m in range(nawf):
                     dHRs[:,n,m,ispin] = 1.0j*alat*ANGSTROM_AU*Rfft_aux[:,l]*HRs_aux[:,n,m,ispin]
 
 
@@ -171,15 +171,15 @@
         dHRs = None
 
         # Compute momenta
-        for ik in xrange(dHks_aux.shape[0]):
-            for ispin in xrange(nspin):
+        for ik in range(dHks_aux.shape[0]):
+            for ispin in range(nspin):
                 pks[ik,l,:,:,ispin] = np.conj(v_kp[ik,:,:,ispin].T).dot \
                     (dHks_aux[ik,:,:,ispin]).dot(v_kp[ik,:,:,ispin])[:bnd,:bnd]
 
 
         if spin_Hall:
-            for ik in xrange(pks.shape[0]):
-                for ispin in xrange(nspin):
+            for ik in range(pks.shape[0]):
+                for ispin in range(nspin):
                     jks[ik,l,:,:,ispin] = (np.conj(v_kp[ik,:,:,ispin].T).dot \
                         (0.5*(np.dot(Sj,dHks_aux[ik,:,:,ispin])+np.dot(dHks_aux[ik,:,:,ispin],Sj))).dot(v_kp[ik,:,:,ispin]))[:bnd,:bnd]
         if spin_Hall:
@@ -194,12 +194,12 @@
     if eff_mass == True: 
         tks = np.zeros((kq_aux.shape[1],3,3,bnd,bnd,nspin),dtype=complex)
 
-        for l in xrange(3):
-            for lp in xrange(3):
+        for l in range(3):
+            for lp in range(3):
                 d2HRs = np.zeros((HRs_aux.shape[0],nawf,nawf,nspin),dtype=complex)
-                for ispin in xrange(nspin):
-                    for n in xrange(nawf):
-                        for m in xrange(nawf):
+                for ispin in range(nspin):
+                    for n in range(nawf):
+                        for m in range(nawf):
                             d2HRs[:,n,m,ispin] = -1.0*alat**2*ANGSTROM_AU**2*Rfft_aux[:,l]*Rfft_aux[:,lp]*HRs_aux[:,n,m,ispin]
 
 
@@ -222,8 +222,8 @@
 
                 # Compute kinetic energy
 
-                for ik in xrange(d2Hks_aux.shape[0]):
-                    for ispin in xrange(nspin):
+                for ik in range(d2Hks_aux.shape[0]):
+                    for ispin in range(nspin):
                         tks[ik,l,lp,:,:,ispin] = (np.conj(v_kp[ik,:,:,ispin].T).dot \
                             (d2Hks_aux[ik,:,:,ispin]).dot(v_kp[ik,:,:,ispin]))[:bnd,:bnd]
 
@@ -234,10 +234,10 @@
 
         # Compute effective mass
         mkm1 = np.zeros((tks.shape[0],bnd,3,3,nspin),dtype=complex)
-        for ik in xrange(tks.shape[0]):
-            for ispin in xrange(nspin):
-                for n in xrange(bnd):
-                    for m in xrange(bnd):
+        for ik in range(tks.shape[0]):
+            for ispin in range(nspin):
+                for n in range(bnd):
+                    for m in range(bnd):
                         if m != n:
                             mkm1[ik,n,ipol,jpol,ispin] += (pks[ik,ipol,n,m,ispin]*pks[ik,jpol,m,n,ispin]+pks[ik,jpol,n,m,ispin]*pks[ik,ipol,m,n,ispin]) / \
                                                         (E_k[ik,n,ispin]-E_k[ik,m,ispin]+1.e-16)
@@ -251,9 +251,9 @@
 
         #mkm1 *= ELECTRONVOLT_SI**2/H_OVER_TPI**2*ELECTRONMASS_SI
         if rank == 0:
-            for ispin in xrange(nspin):
+            for ispin in range(nspin):
                 f=open(os.path.join(inputpath,'effmass'+'_'+str(LL[ipol])+str(LL[jpol])+'_'+str(ispin)+'.dat'),'w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in np.real(mkm1[ik,:bnd,ipol,jpol,ispin]):s += "% 3.5f\t"%j
                     s+="\n"
@@ -285,9 +285,9 @@
         mu = -0.2 # chemical potential in eV)
         Om_znk = np.zeros((pks.shape[0],bnd),dtype=float)
         Om_zk = np.zeros((pks.shape[0],1),dtype=float)
-        for ik in xrange(pks.shape[0]):
-            for n in xrange(bnd):
-                for m in xrange(bnd):
+        for ik in range(pks.shape[0]):
+            for n in range(bnd):
+                for m in range(bnd):
                     if m!= n:
                         if Berry:
                             Om_znk[ik,n] += -1.0*np.imag(pks[ik,jpol,n,m,0]*pks[ik,ipol,m,n,0]-pks[ik,ipol,n,m,0]*pks[ik,jpol,m,n,0]) / \
@@ -302,14 +302,14 @@
         Om_zk = gather_full(Om_zk,npool)
         if rank == 0:
             f=open(os.path.join(inputpath,'Omega_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,-Om_zk[ik,0]))
             f.close()
     if spin_Hall:
         Omj_zk = gather_full(Omj_zk,npool)
         if rank == 0:
             f=open(os.path.join(inputpath,'Omegaj_'+str(LL[spol])+'_'+str(LL[ipol])+str(LL[jpol])+'.dat'),'w')
-            for ik in xrange(nkpi):
+            for ik in range(nkpi):
                 f.write('%3d  %.5f \n' %(ik,Omj_zk[ik,0]))
             f.close()
 
@@ -317,12 +317,12 @@
     if rank == 0:
         if spin_orbit: bnd *= 2
         velk = np.zeros((nkpi,3,bnd,nspin),dtype=float)
-        for n in xrange(bnd):
+        for n in range(bnd):
             velk[:,:,n,:] = np.real(pks[:,:,n,n,:])
-        for ispin in xrange(nspin):
-            for l in xrange(3):
+        for ispin in range(nspin):
+            for l in range(3):
                 f=open(os.path.join(inputpath,'velocity_'+str(l)+'_'+str(ispin)+'.dat'),'w')
-                for ik in xrange(nkpi):
+                for ik in range(nkpi):
                     s="%d\t"%ik
                     for  j in velk[ik,l,:bnd,ispin]:s += "%3.5f\t"%j
                     s+="\n"
@@ -338,7 +338,7 @@
 
     auxh = np.zeros((nawf,nawf,kq.shape[1],nspin),dtype=complex,order="C")
 
-    for ispin in xrange(nspin):
+    for ispin in range(nspin):
         auxh[:,:,:,ispin]=np.tensordot(HRaux[:,:,:,ispin],kdot,axes=([2],[0]))
 
     kdot  = None
--- PAOFLOW/src/defs/do_z2pack.py	(original)
+++ PAOFLOW/src/defs/do_z2pack.py	(refactored)
@@ -35,7 +35,7 @@
 
     # print each cell weight
     j=0
-    for i in xrange(nlines):
+    for i in range(nlines):
         j=i*nl
         f.write ('   '.join('{:d} '.format(j) for j in kq_wght[j:j+nl]))
         f.write ('\n')
@@ -45,9 +45,9 @@
         f.write ('   '.join('{:d} '.format(j) for j in kq_wght[nlines*nl:nkpts]))
         f.write ('\n')
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
@@ -62,7 +62,7 @@
                 ix=-round(Rx*nk1,0)
                 iy=-round(Ry*nk2,0)
                 iz=-round(Rz*nk3,0)
-                for m in xrange(nawf):
-                    for l in xrange(nawf):
+                for m in range(nawf):
+                    for l in range(nawf):
                         # l+1,m+1 just to start from 1 not zero
                         f.write (('%3d %3d %3d %5d %5d %14f %14f \n') %(ix,iy,iz,l+1,m+1,HRs[l,m,i,j,k,0].real,HRs[l,m,i,j,k,0].imag))
--- PAOFLOW/src/defs/get_K_grid_fft.py	(original)
+++ PAOFLOW/src/defs/get_K_grid_fft.py	(refactored)
@@ -18,9 +18,9 @@
     K_wght /= nktot
     idk = np.zeros((nk1,nk2,nk3),dtype=int)
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
--- PAOFLOW/src/defs/get_R_grid_fft.py	(original)
+++ PAOFLOW/src/defs/get_R_grid_fft.py	(refactored)
@@ -19,9 +19,9 @@
     R_wght = np.ones((nrtot),dtype=float)
     idx = np.zeros((nk1,nk2,nk3),dtype=int)
 
-    for i in xrange(nk1):
-        for j in xrange(nk2):
-            for k in xrange(nk3):
+    for i in range(nk1):
+        for j in range(nk2):
+            for k in range(nk3):
                 n = k + j*nk3 + i*nk2*nk3
                 Rx = float(i)/float(nk1)
                 Ry = float(j)/float(nk2)
--- PAOFLOW/src/defs/kpnts_interpolation_mesh.py	(original)
+++ PAOFLOW/src/defs/kpnts_interpolation_mesh.py	(refactored)
@@ -480,9 +480,9 @@
     kq=np.copy(points)
     cart = False
     if cart:
-        for n in xrange(kq.shape[1]):
+        for n in range(kq.shape[1]):
             kq[:,n]=np.dot(kq[:,n],b_vectors)
-    for i in xrange(kq.shape[1]):
+    for i in range(kq.shape[1]):
         path_file+="%s %s %s\n"%(kq[0,i],kq[1,i],kq[2,i])
 
     if rank==0:
@@ -540,7 +540,7 @@
         point1 = None
         point2 = None
 
-        for index2 in xrange(len(a)-1):
+        for index2 in range(len(a)-1):
             try:
                 point1 = a[index2]
                 point2 = a[index2+1]
--- PAOFLOW/src/defs/load_balancing.py	(original)
+++ PAOFLOW/src/defs/load_balancing.py	(refactored)
@@ -26,7 +26,7 @@
 def load_sizes(size,n,dim):
     sizes = np.empty((size,3),dtype=int)
     splitsize = 1.0/size*n
-    for i in xrange(size):
+    for i in range(size):
         start = int(round(i*splitsize))
         stop = int(round((i+1)*splitsize))
         sizes[i][0] = dim*(stop-start)
--- PAOFLOW/src/defs/pfaffian.py	(original)
+++ PAOFLOW/src/defs/pfaffian.py	(refactored)
@@ -123,7 +123,7 @@
     if calc_q:
         Q = np.eye(A.shape[0], dtype=A.dtype)
 
-    for i in xrange(A.shape[0]-2):
+    for i in range(A.shape[0]-2):
         #Find a Householder vector to eliminate the i-th column
         v, tau, alpha = householder(A[i+1:,i])
         A[i+1, i] = alpha
@@ -177,7 +177,7 @@
     if calc_P:
         Pv = np.arange(n)
 
-    for k in xrange(n-2):
+    for k in range(n-2):
         #First, find the largest entry in A[k+1:,k] and
         #permute it to A[k+1,k]
         kp = k+1+np.abs(A[k+1:,k]).argmax()
@@ -287,7 +287,7 @@
 
     pfaffian_val = 1.0
 
-    for k in xrange(0, n-1, 2):
+    for k in range(0, n-1, 2):
         #First, find the largest entry in A[k+1:,k] and
         #permute it to A[k+1,k]
         kp = k+1+np.abs(A[k+1:,k]).argmax()
@@ -365,7 +365,7 @@
 
     pfaffian_val = 1.
 
-    for i in xrange(A.shape[0]-2):
+    for i in range(A.shape[0]-2):
         #Find a Householder vector to eliminate the i-th column
         v, tau, alpha = householder(A[i+1:,i])
         A[i+1, i] = alpha
--- PAOFLOW/src/defs/plot_compare_PAO_DFT_eigs.py	(original)
+++ PAOFLOW/src/defs/plot_compare_PAO_DFT_eigs.py	(refactored)
@@ -23,7 +23,7 @@
 
     ispin = 0 #plots only 1 spin channel
     #for ispin in xrange(nspin):
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         if read_S:
             eigval,_ = LA.eigh(Hks[:,:,ik,ispin],Sks[:,:,ik],lower=False)
         else:
@@ -32,7 +32,7 @@
 
     fig=plt.figure
     nbnds_dft,_,_=my_eigsmat.shape
-    for i in xrange(nbnds_dft):
+    for i in range(nbnds_dft):
         #print("{0:d}".format(i))
         yy = my_eigsmat[i,:,ispin]
         if i==0:
@@ -40,7 +40,7 @@
         else:
             plt.plot(yy,'ok',markersize=3,markeredgecolor='lime',markerfacecolor='lime')
 
-    for i in xrange(nawf):
+    for i in range(nawf):
         yy = E_k[i,:,ispin]
         if i==0:
             plt.plot(yy,'ok',markersize=2,markeredgecolor='None',label='PAO')
--- PAOFLOW/src/defs/read_new_QE_output_xml_parse.py	(original)
+++ PAOFLOW/src/defs/read_new_QE_output_xml_parse.py	(refactored)
@@ -89,7 +89,7 @@
                 # Atomic Positions
                 natoms=int(float(elem.findall("atomic_structure")[0].attrib['nat']))
                 tau = np.zeros((natoms,3),dtype=float)
-                for n in xrange(natoms):
+                for n in range(natoms):
                     aux = elem.findall("atomic_structure/atomic_positions/atom")[n].text.split()
                     tau[n,:]=np.array(aux,dtype="float32")
 			
--- PAOFLOW/src/defs/smearing.py	(original)
+++ PAOFLOW/src/defs/smearing.py	(refactored)
@@ -32,7 +32,7 @@
     nh = 5
     coeff = np.zeros(2*nh)
     coeff[0] = 1.
-    for n in xrange(2,2*nh,2):
+    for n in range(2,2*nh,2):
         m = n/2
         coeff[n] = (-1.)**m/(math.factorial(m)*4.0**m*np.sqrt(np.pi))
 
@@ -49,7 +49,7 @@
     nh = 5
     coeff = np.zeros(2*nh)
     coeff[0] = 0.
-    for n in xrange(2,2*nh,2):
+    for n in range(2,2*nh,2):
         m = n/2
         coeff[n-1] = (-1.)**m/(math.factorial(m)*4.0**m*np.sqrt(np.pi))
 
--- PAOFLOW/src/defs/write_PAO_eigs.py	(original)
+++ PAOFLOW/src/defs/write_PAO_eigs.py	(refactored)
@@ -30,7 +30,7 @@
     if evecs:
         v_k = np.zeros((nkpnts,nawf,nawf),dtype=complex)
 
-    for ik in xrange(nkpnts):
+    for ik in range(nkpnts):
         if read_S:
             eigval,eigvec = LA.eigh(Hks[:,:,ik,ispin],Sks[:,:,ik])
         else:
@@ -43,13 +43,13 @@
         ipad = False
         if ipad:
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(nkpnts):
-                for nb in xrange(nawf):
+            for ik in range(nkpnts):
+                for nb in range(nawf):
                     f.write('%3d  %.5f \n' %(ik,E_k[ik,nb]))
             f.close()
         else:
             f=open(os.path.join(inputpath,'bands_'+str(ispin)+'.dat'),'w')
-            for ik in xrange(nkpnts):
+            for ik in range(nkpnts):
                 s="%d\t"%ik
                 for  j in E_k[ik,:]:s += "%3.5f\t"%j
                 s+="\n"
--- PAOFLOW/src/externals/acbn0/examples/MgO/Molecule.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/Molecule.py	(refactored)
@@ -88,7 +88,7 @@
             nat = int(line.split()[0])
             title = lines.pop(0)
             atoms = []
-            for i in xrange(nat):
+            for i in range(nat):
                 line = lines.pop(0)
                 words = line.split()
                 atno = sym2no[words[0]]
@@ -299,7 +299,7 @@
 
 
 sym2no = {}
-for i in xrange(len(symbol)):
+for i in range(len(symbol)):
     sym2no[symbol[i]] = i
     sym2no[symbol[i].lower()] = i
 
@@ -485,14 +485,14 @@
     def update_from_atuples(self,geo):
         nat = len(geo)
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_from_atuple(geo[i])
         return
 
     def update_coords(self,coords):
         nat = len(coords)/3
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_coords(coords[3*i:3*i+3])
         return
 
@@ -554,9 +554,9 @@
     def get_enuke(self):
         enuke = 0.
         nat = len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             ati = self.atoms[i]
-            for j in xrange(i):
+            for j in range(i):
                 atj = self.atoms[j]
                 enuke += ati.get_nuke_chg()*atj.get_nuke_chg()/ati.dist(atj)
         return enuke
--- PAOFLOW/src/externals/acbn0/examples/MgO/pyints.py	(original)
+++ PAOFLOW/src/externals/acbn0/examples/MgO/pyints.py	(refactored)
@@ -17,10 +17,10 @@
                      dexps,dcoefs,dnorms,xyzd,powd):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],powa[i],aexps[i],
                                              xyzb,bnorms[j],powb[j],bexps[j],
                                              xyzc,cnorms[k],powc[k],cexps[k],
@@ -35,10 +35,10 @@
                      dexps,dcoefs,dnorms,xyzd,powdx,powdy,powdz):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],(powax[i],poway[i],powaz[i]),aexps[i],
                                              xyzb,bnorms[j],(powax[j],poway[j],powaz[j]),bexps[j],
                                              xyzc,cnorms[k],(powax[k],poway[k],powaz[k]),cexps[k],
@@ -68,9 +68,9 @@
     Bz = B_array(na,nb,nc,nd,zp,za,zb,zq,zc,zd,gamma1,gamma2,delta) #needs B_array
 
     sum = 0.
-    for I in xrange(la+lb+lc+ld+1):
-        for J in xrange(ma+mb+mc+md+1):
-            for K in xrange(na+nb+nc+nd+1):
+    for I in range(la+lb+lc+ld+1):
+        for J in range(ma+mb+mc+md+1):
+            for K in range(na+nb+nc+nd+1):
                 sum = sum + Bx[I]*By[J]*Bz[K]*Fgamma(I+J+K,0.25*rpq2/delta) #needs Fgamma
 
     return 2*pow(pi,2.5)/(gamma1*gamma2*sqrt(gamma1+gamma2)) \
@@ -84,11 +84,11 @@
 def B_array(l1,l2,l3,l4,p,a,b,q,c,d,g1,g2,delta):
     Imax = l1+l2+l3+l4+1
     B = [0]*Imax
-    for i1 in xrange(l1+l2+1):
-        for i2 in xrange(l3+l4+1):
-            for r1 in xrange(i1/2+1):
-                for r2 in xrange(i2/2+1):
-                    for u in xrange((i1+i2)/2-r1-r2+1):
+    for i1 in range(l1+l2+1):
+        for i2 in range(l3+l4+1):
+            for r1 in range(i1/2+1):
+                for r2 in range(i2/2+1):
+                    for u in range((i1+i2)/2-r1-r2+1):
                         I = i1+i2-2*(r1+r2)-u
                         B[I] = B[I] + B_term(i1,i2,r1,r2,u,l1,l2,l3,l4, 
                                              p,a,b,q,c,d,g1,g2,delta)   #needs B_term
@@ -108,7 +108,7 @@
 def binomial_prefactor(s,ia,ib,xpa,xpb):
     "From Augspurger and Dykstra"
     sum = 0
-    for t in xrange(s+1):
+    for t in range(s+1):
         if s-ia <= t <= ib:
                 sum = sum + binomial(ia,s-t)*binomial(ib,t)* \
                   pow(xpa,ia-s+t)*pow(xpb,ib-t)
@@ -186,7 +186,7 @@
 
     ap = a
     delt = sum = 1./a
-    for i in xrange(ITMAX):
+    for i in range(ITMAX):
         ap=ap+1.
         delt=delt*x/ap
         sum=sum+delt
@@ -207,7 +207,7 @@
     c=1./FPMIN
     d=1./b
     h=d
-    for i in xrange(1,ITMAX+1):
+    for i in range(1,ITMAX+1):
         an=-i*(i-a)
         b=b+2.
         d=an*d+b
@@ -234,7 +234,7 @@
     tmp=x+5.5
     tmp = tmp - (x+0.5)*log(tmp)
     ser=1.000000000190015 # don't you just love these numbers?!
-    for j in xrange(6):
+    for j in range(6):
         y = y+1
         ser = ser+cof[j]/y
     return -tmp+log(2.5066282746310005*ser/x);
--- PAOFLOW/src/externals/acbn0/src/Molecule.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/Molecule.py	(refactored)
@@ -88,7 +88,7 @@
             nat = int(line.split()[0])
             title = lines.pop(0)
             atoms = []
-            for i in xrange(nat):
+            for i in range(nat):
                 line = lines.pop(0)
                 words = line.split()
                 atno = sym2no[words[0]]
@@ -299,7 +299,7 @@
 
 
 sym2no = {}
-for i in xrange(len(symbol)):
+for i in range(len(symbol)):
     sym2no[symbol[i]] = i
     sym2no[symbol[i].lower()] = i
 
@@ -485,14 +485,14 @@
     def update_from_atuples(self,geo):
         nat = len(geo)
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_from_atuple(geo[i])
         return
 
     def update_coords(self,coords):
         nat = len(coords)/3
         assert nat == len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             self.atoms[i].update_coords(coords[3*i:3*i+3])
         return
 
@@ -554,9 +554,9 @@
     def get_enuke(self):
         enuke = 0.
         nat = len(self.atoms)
-        for i in xrange(nat):
+        for i in range(nat):
             ati = self.atoms[i]
-            for j in xrange(i):
+            for j in range(i):
                 atj = self.atoms[j]
                 enuke += ati.get_nuke_chg()*atj.get_nuke_chg()/ati.dist(atj)
         return enuke
--- PAOFLOW/src/externals/acbn0/src/pyints.py	(original)
+++ PAOFLOW/src/externals/acbn0/src/pyints.py	(refactored)
@@ -17,10 +17,10 @@
                      dexps,dcoefs,dnorms,xyzd,powd):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],powa[i],aexps[i],
                                              xyzb,bnorms[j],powb[j],bexps[j],
                                              xyzc,cnorms[k],powc[k],cexps[k],
@@ -35,10 +35,10 @@
                      dexps,dcoefs,dnorms,xyzd,powdx,powdy,powdz):
 
     Jij = 0.
-    for i in xrange(len(aexps)):
-        for j in xrange(len(bexps)):
-            for k in xrange(len(cexps)):
-                for l in xrange(len(dexps)):
+    for i in range(len(aexps)):
+        for j in range(len(bexps)):
+            for k in range(len(cexps)):
+                for l in range(len(dexps)):
                     incr = coulomb_repulsion(xyza,anorms[i],(powax[i],poway[i],powaz[i]),aexps[i],
                                              xyzb,bnorms[j],(powax[j],poway[j],powaz[j]),bexps[j],
                                              xyzc,cnorms[k],(powax[k],poway[k],powaz[k]),cexps[k],
@@ -68,9 +68,9 @@
     Bz = B_array(na,nb,nc,nd,zp,za,zb,zq,zc,zd,gamma1,gamma2,delta) #needs B_array
 
     sum = 0.
-    for I in xrange(la+lb+lc+ld+1):
-        for J in xrange(ma+mb+mc+md+1):
-            for K in xrange(na+nb+nc+nd+1):
+    for I in range(la+lb+lc+ld+1):
+        for J in range(ma+mb+mc+md+1):
+            for K in range(na+nb+nc+nd+1):
                 sum = sum + Bx[I]*By[J]*Bz[K]*Fgamma(I+J+K,0.25*rpq2/delta) #needs Fgamma
 
     return 2*pow(pi,2.5)/(gamma1*gamma2*sqrt(gamma1+gamma2)) \
@@ -84,11 +84,11 @@
 def B_array(l1,l2,l3,l4,p,a,b,q,c,d,g1,g2,delta):
     Imax = l1+l2+l3+l4+1
     B = [0]*Imax
-    for i1 in xrange(l1+l2+1):
-        for i2 in xrange(l3+l4+1):
-            for r1 in xrange(i1/2+1):
-                for r2 in xrange(i2/2+1):
-                    for u in xrange((i1+i2)/2-r1-r2+1):
+    for i1 in range(l1+l2+1):
+        for i2 in range(l3+l4+1):
+            for r1 in range(i1/2+1):
+                for r2 in range(i2/2+1):
+                    for u in range((i1+i2)/2-r1-r2+1):
                         I = i1+i2-2*(r1+r2)-u
                         B[I] = B[I] + B_term(i1,i2,r1,r2,u,l1,l2,l3,l4, 
                                              p,a,b,q,c,d,g1,g2,delta)   #needs B_term
@@ -108,7 +108,7 @@
 def binomial_prefactor(s,ia,ib,xpa,xpb):
     "From Augspurger and Dykstra"
     sum = 0
-    for t in xrange(s+1):
+    for t in range(s+1):
         if s-ia <= t <= ib:
                 sum = sum + binomial(ia,s-t)*binomial(ib,t)* \
                   pow(xpa,ia-s+t)*pow(xpb,ib-t)
@@ -186,7 +186,7 @@
 
     ap = a
     delt = sum = 1./a
-    for i in xrange(ITMAX):
+    for i in range(ITMAX):
         ap=ap+1.
         delt=delt*x/ap
         sum=sum+delt
@@ -207,7 +207,7 @@
     c=1./FPMIN
     d=1./b
     h=d
-    for i in xrange(1,ITMAX+1):
+    for i in range(1,ITMAX+1):
         an=-i*(i-a)
         b=b+2.
         d=an*d+b
@@ -234,7 +234,7 @@
     tmp=x+5.5
     tmp = tmp - (x+0.5)*log(tmp)
     ser=1.000000000190015 # don't you just love these numbers?!
-    for j in xrange(6):
+    for j in range(6):
         y = y+1
         ser = ser+cof[j]/y
     return -tmp+log(2.5066282746310005*ser/x);
--- PAOFLOW/src/externals/genPAW_ld1/UPF_GaussFit2.py	(original)
+++ PAOFLOW/src/externals/genPAW_ld1/UPF_GaussFit2.py	(refactored)
@@ -98,7 +98,7 @@
 
     with open("wfc"+label+".dat", "wt") as f:
         gto_r = gto(r, l, params)
-        for i in xrange(len(wfc)):
+        for i in range(len(wfc)):
             f.write("%f %f %f\n" % (r[i], wfc[i], r[i]*gto_r[i]))
     pylab.plot(r, wfc, '.', label=label+"_orig")
     pylab.plot(r, r*gto(r, l, params), label=label+"_fit")
@@ -202,7 +202,7 @@
 #### get element name ####
 if upfver == 1:
     text = root.find('PP_HEADER').text.split()
-    for i in xrange(len(text)):
+    for i in range(len(text)):
         if text[i] == 'Element':
             element = text[i-1].strip()
             break
@@ -233,7 +233,7 @@
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
    
@@ -254,7 +254,7 @@
         occ = float(occ)
         wfc = []
 
-        for i in xrange(nlines):
+        for i in range(nlines):
             wfc.extend(map(float, data.readline().split()))
         wfc = np.array(wfc)
 
@@ -288,12 +288,12 @@
         if npoints % 4 != 0: nlines += 1
         beta = []
 
-        for i in xrange(nlines):
+        for i in range(nlines):
             beta.extend(map(float, data.readline().split()))
         print beta
         beta = np.array(beta)
         f = open("beta_%i_%i.dat" % (ibeta, l), 'w')
-        for i in xrange(len(beta)):
+        for i in range(len(beta)):
             f.write("%f %f\n" % (r[i], beta[i]))
         f.close()
         line = data.readline()
@@ -306,7 +306,7 @@
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
 
@@ -314,7 +314,7 @@
     if pot is None: quit()
     v = [float(x) for x in pot.text.split()]
     f = open('vlocal_ae.dat', 'w')
-    for i in xrange(len(v)):
+    for i in range(len(v)):
         f.write("%f %f\n" % (r[i], v[i]))
     f.close()
 
--- PAOFLOW/src/externals/transportPAO/tests/test05/plot.py	(original)
+++ PAOFLOW/src/externals/transportPAO/tests/test05/plot.py	(refactored)
@@ -6,7 +6,7 @@
 a_k = np.zeros((300,191),dtype=float)
 Efermi = 0.0#12.79 
 
-for i in xrange(300):
+for i in range(300):
     a = f.readline()
     aux = a.split()
     a = np.array(aux,dtype="float32")
--- PAOFLOW/testing/check_test.py	(original)
+++ PAOFLOW/testing/check_test.py	(refactored)
@@ -85,7 +85,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -147,7 +147,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/testing/run_test.py	(original)
+++ PAOFLOW/testing/run_test.py	(refactored)
@@ -118,7 +118,7 @@
         if refPattern[len(refPattern)-1] != '/':
             refPattern += '/'
 
-    for n in xrange(len(pwdir)):
+    for n in range(len(pwdir)):
         os.chdir(pwdir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
 
@@ -129,7 +129,7 @@
             quit()
         os.chdir('../../')
 
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
 
--- PAOFLOW/testing/nosmear/check_test.py	(original)
+++ PAOFLOW/testing/nosmear/check_test.py	(refactored)
@@ -78,7 +78,7 @@
 
         # Compare computed error against data average
         validData = True
-        for j in xrange(nCol-1):
+        for j in range(nCol-1):
 
             # Store maximum absolute error
             if absoluteError[j] > maxError:
@@ -136,7 +136,7 @@
             refPattern += '/'
 
     # Verify data for each test matching the input or default pattern
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         verifyData(subdir, refPattern)
--- PAOFLOW/testing/nosmear/run_test.py	(original)
+++ PAOFLOW/testing/nosmear/run_test.py	(refactored)
@@ -88,7 +88,7 @@
         if refPattern[len(refPattern)-1] != '/':
             refPattern += '/'
 
-    for n in xrange(len(alldir)):
+    for n in range(len(alldir)):
         os.chdir(alldir[n])
         subdir = str(os.getcwd()).split('/')[len(str(os.getcwd()).split('/'))-1]
         try:
